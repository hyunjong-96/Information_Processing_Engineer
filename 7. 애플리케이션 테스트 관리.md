# *61. 애플리케이션 테스트

1. 애플리케이션 테스트의 기본 원리
   - **완벽한 테스트 불가**
   - **개발 초기에 테스팅 시작**
   - **결함집중** : 결함의 80%는 20%에 집중
   - **살충제 페러독스** : 동일한 테스트케이스를 반복하면 새로운 결함을 찾을수 없다
   - **테스팅은 정황에 의존** : 소프트웨어 성격에 맞게 테스트 실시
   - **오류-부재의 궤변** : 요구사항을 만족하지 못하면 오류가 없어도 품질이 좋지못하다

# *62. 애플리케이션 테스트의 분류

1. 프로그램 실행 여부에 따른 테스트
   - 정적 테스트 : 프로그램을 실행하지 않고 명세서나 코드를 대상으로 분석하는 테스트
     - 워크스루 : 전문가들이 검토
     - 인스펙션 : 워크스루를 발전시킨형태,전문가를 통해 오류를 찾아내는 공식적 검토 방법
     - 코드검사
   - 동적 테스트 : 프로그램을 실행하여 오류를 찾는 테스트
     - 블랙박스테스트
     - 화이트박스 테스트
2. 테스트 기반에 따른 테스트
   - 명세 기반 : 요구사항에 대한 명세를 모두 테스트 케이스로 만들어 구현
     - 동등 분할, 경계 값 분석
   - 구조 기반 : 내부의 논리 흐름에 따라 테스트 케이스를 작성
     - 구문 커버리지, 분기 커버리지, 조건 커버리지
   - 경험 기반 : 테스터의 경험기반
     - 체크 리스트
3. 시각에 따른 테스트
   - 검증(Verification) 테스트 : 개발자의 시각에서 테스트
   - 확인(Validation) 테스트 : 사용자의 시각에서 테스트
4. 목적에 따른 테스트
   - 회복 테스트 : 결함을 주고 얼마나 빠르게 회복하는지
   - 안전 테스트 : 불법적인 침입으로부터 시스템을 보호할수 있는지
   - 성능 테스트 : 응답 시간, 처리량 테스트
   - 강도 테스트 : 과도한 정보량을 부과해 과부화에서도 정상적인 실행을 하는지
   - 구조 테스트 : 논리적인 경로, 코드 복잡도 테스트
   - 회귀 테스트 : 수정된 코드에서 새로운 결함이 없음을 확인
   - 병행 테스트 : 기존sw와 수정된sw에 동일한 입력값을 주고 비교

# *63. 테스트 기법에 따른 애플리케이션 테스트

1. **화이트박스 테스트**
   - 모듈의 원시코드를 오픈시킨 상태에서 논리적인 모든 경로를 테스트하여 테스트 케이스 설계
   - 원시 코드의 모든 문장을 한 번 이상 실행함으로써 실행
   - 화이트박스 테스트의 종류
     - 기초 경로 검사 : 테스트 케이스의 설계자가 절차적 설계의 논리적 복잡성을 측정할 수 있게 해주는 테스트 기법, 테스트 결과는 실행 경로의 기초를 정의하는 데 지침으로 사용됨.
     - 제어 구조 검사 
       - 조건 검사 : 프로그램 모듈 내에 있는 논리적 조건을 테스트하는 테스트 케이스 설계 기법
       - 루프 검사 : 프로그램의 반복구조에 초점을 맞춰 실시하는 테스트 케이스 설계 기법
       - 데이터 흐름 검사 : 프로그램에서 변수의 정의와 변수 사용의 위치에 초점을 맞춰 실시하는 테스트 케이스 설계 기법
   - 화이트박스 테스트의 검증 기준 : 테스트 케이스들이 테스트에 얼마나 적정한가 판단하는 기준
     - **구문 검증 기준(Statement Coverage)** : 모든 구문이 한 번 이상 수행되도록 테스트 케이스 설계
     - **분기 검증 기준(Branch Coverage)** : 모든 조건문이 True,False 한 번 이상 수행되도록 테스트 케이스 설계
     - **조건 검증 기준(Condition Coverage)** : 각 조건문에 포함된 개별 조건식의 결과가 True인 경우와 False인 경우가 한 번 이상 수행되도록 설계하는 테스트 케이스 설계
     - **분기/조건 기준(Branch/Condition Coverage)** : 모든 조건문과 각 조건문에 포함된 개별 조건식의 결과가 True인 경우와 False인 경우가 한 번 이상 수행되도록 테스트 케이스 설계
2. **블랙박스 테스트**
   - 소프트웨어가 수행할 특정 기능을 알기 위해서 각 기능이 완전히 작동되는 것을 입증 하는 테스트.
   - 요구사항 명세를 보면서 테스트하는것, 구현된 기능을 테스트
   - 블랙박스 테스트 종류(**동경원오비**)
     - **동**치 분할 : 입력 자료에 초점을 두어 타당한 입력자료와 타당하지 않은 입력자료의 개수를 균등하게 하여 테스트 케이스 정의.
     - **경**계값 분석 : 입력 조건의 경계값을 테스트 케이스로 선정하여 검사.
     - **원**인-효과 그래프 검사 : 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효용성이 높은 테스트 케이스를 선정하여 검사하는 기법
     - **오**류 예측 검사 : 경험이나 감각으로 테스트하는 기법
     - **비**교 검사 : 여러 버전의 프로그램에 동일한 테스트 자료를 제공하여 동일한 결과가 출력되는지 테스트하는 기법

# *64. 개발 단계에 따른 애플리케이션 테스트

1. 소프트웨어 생명 주기의 V-모델
   - 소프트웨어 개발 단계
     1. 요구사항
     2. 분석
     3. 설계
     4. 구현
   - **테스트 단계**
     1. **단위 테스트** : 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트하는것
        - 구조 기반 테스트 : 프로그램 내부 구조 및 복잡도를 검증하는 화이트박스 테스트 시행
        - 명세 기반 테스트 : 목적 및 실행 코드 기반의 블랙박스 테스트 시행
        - 단위 테스트 종류(**인자실오**)
          - **인**터페이스 테스트
          - **자**료구조 테스트
          - **실**행 경로 테스트
          - **오**류 처리 테스트
     2. **통합 테스트** : 통합된 컴포넌트 간의 상호 작용 오류 검사
     3. **시스템 테스트** : 해당 컴퓨터 시스템에서 완벽하게 수행되는가를 점검하는 테스트
        - 기능적 요구사항 : 요구사항 명세서, 유스케이스 등 명세서 기반의 **블랙박스 테스트** 시행
        - 비기능적 요구사항 : 성능 테스트, 회복 테스트 등 구조적 요소에 대한 **화이트박스 테스트** 시행
     4. **인수 테스트** : 소프트웨어가 사용자의 요구사항을 충족하는지 중점을 두고 테스트
        - 알파 테스트 : 개발자 장소에서 사용자가 행하는 테스트
        - 베타 테스트 : 선정된 최종 사용자가 여러 명의 사용자 앞에서 행하는 테스트 기법

# *65. 통합 테스트

1. 비점진적 통합 방법 : 단계적으로 통합하는 절차 없이 모듈이 모두 결합되어있는 프로그램 전체를 테스트하는 방법
   - 빅뱅 통합 테스트 : 단위 테스트가 끝난 모듈을 한꺼번에 결합시켜 테스트하는 방법
2. 점진적 통합 방법 : 모듈 단위로 단계적으로 통합하면서 테스트하는 방식
   //오류 수정 용이
   //인터페이스와 연관된 오류를 완전히 테스트할 가능성이 높다
   - **하향식 통합 테스트** : 프로그램의 상위 모듈에서 하위 모듈방향으로 통합하면서 테스트하는 기법
     1. 주요 제어 모듈은 작성된 프로그램을 사용, 제어 모듈의 종속 모듈들은 **스텁(stub)**으로 대체
     2. 깊이 우선또는 넓이 우선 등의 통합 방식에 따라 스텁들이 한번에 하나씩 실제 모듈로 교체
     3. 모듈이 통합될때마다 테스트
     4. 회귀 테스트 실시
   - **상향식 통합 테스트** : 프로그램의 하위 모듈에서 상위 모듈방향으로 통합하면서 테스트하는 기법
     1. 하위 모듈들들 **클러스터(Cluster)**로 결합
     2. 상위 모듈에서 데이터의 입출력을 확인하기 위해 더미 모듈인 **드라이버(Driver)**를 작성
     3. 통합된 클러스터 단위로 테스트
     4. 테스트가 완료되면 클러스터는 상위로 이동하여 결합하고 드라이버는 실제 모듈로 대체
   - **혼합식 통합 테스트** : 하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합을 사용하여 최적의 테스트를 지원하는 방식

# 66. 애플리케이션 테스트 프로세스

1. 애플리케이션 테스트 프로세스
   1. 테스트 계획
   2. 테스트 분석 및 디자인
   3. 테스트 케이스 및 시나리오 작성
   4. 테스트 수행
   5. 테스트 결과 및 리포팅
   6. 결함 추적 및 관리

- 애플리케이션 테스트를 마치면
  - 테스트 계획서 : 테스트 수행을 계획한 문서
  - 테스트 케이스 : 테스트 항목의 명세서
  - 테스트 시나리오 : 테스트 케이스의 동작 순서를 기술한 문서
  - 테스트 결과서 : 테스트 결과를 비교,분석한 내용을 정리한 문서

# *67. 테스트 케이스/ 테스트 시나리오/ 테스트 오라클

1. 테스트 케이스 : 사용자의 요구사항을 정확하게 준수했는지 확인하기 위해 테스트 항목에 대한 명세서.
   - 명세 기반 테스트의 산출물
2. 테스트 시나리오 : 여러 개의 테스트 케이스들을 묶은 집합으로, 테스트 케이스들의 동작 순서를 기술한 문서
   - 테스트 시나리오는 유스케이스간 업무 흐름이 정상적인지를 테스트할 수 있도록 작성해야한다.
3. 테스트 오라클 : 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값을 대입해 비교하는 기법
   - 테스트 오라클 특징(**제수자**)
     - **제**한된 검증
     - **수**학적 기법
     - **자**동화 기능
   - 테스트 오라클 종류(**참샘 추일**)
     - **참** 오라클: 모든 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공
       - 미션 크리티컬한 업무에 사용
     - **샘**플링 오라클 : 특정 테스트 케이스의 입력에 대해서 결과를 제공
     - **추**정 오라클 : 특정 테스트 케이스의 입력에 대한 결과와 나머지 입력 값에 대해서는 추정으로 처리
     - **일**관성 검사 오라클 : 애플리 케이션 변경후 테스트 전과 후의 결과 값이 동일한지 확인

# *68. 테스트 자동화 도구

1. 테스트 자동화 : 테스트 절차를 스크립트 형태로 구현하는 자동화 도구를 적용해서 쉽고 효율적으로 테스트를 수행할 수 있도록 하는것.
   - 사람이 반복적으로 하던 테스트를 자동화 도구를 사용하면 **휴먼에러**를 줄이고 **테스트의 정확성을 유지**하면서 **테스트의 품질을 높일수** 있다
2. 테스트 자동화 도구의 유형(**정실성통하**)
   - **정**적 분석 도구 : 프로그램을 실행하지 않고 분석하는 도구로 코딩 표준, 코드 복잡도 등을 발견하기 위해 사용
   - 테스트 **실**행 도구 : 스크립트 언어를 사용하여 테스트를 실행하는 방법
     - 데이터 주도 접근 방식 : 스프레드시트에 테스트 데이터를 저장하고 이를 읽어 실행하는 방식
     - 키워드 주도 접근 방식 : 스프레드시트에 수행할 동작을 나타내는 키워드와 테스트 데이터를 저장하여 실행하는 방식
   - **성**능 테스트 도구 : 애플리케이션의 처리량, 응답시간, 자원 사용률 등을 인위적으로 적용한 사용자를 만들어 테스트를 수행해서 성능의 목표 달성 여부 확인
   - 테스트 **통**제 도구 : 테스트 계획 및 관리, 테스트 수행, 결함 관리 등을 수행하는 도구
     - 형상 관리 도구
     - 결함 추적/관리도구
   - 테스트 **하**네스 도구 : 테스트가 실행될 환경을 시뮬레이션 하여 컴포넌트 및 모듈이 정상적으로 테스트 되도록하는 도구
     - 테스트 드라이버 : 데이터의 입출력을 확인하기 위한 상위 더미 모듈
     - 테스트 스텁 : 일시적으로 필요한 조건만 가지고 있는 테스트용 모듈
     - 테스트 슈트 : 테스트 케이스의 집합
     - 테스트 케이스 : 사용자의 요구사항을 준수했는지 확인하기 위해 만들어진 테스트 항목의 명세서
     - 테스트 스크립트 : 자동화된 테스트 실행 절차에 대한 명세서
     - 목 오브젝트 : 사전에 사용자의 행위를 조건부로 작성하면 그 상황에 맞는 예정된 행위를 수행하는 객체

# *69. 결함 관리

- 결함 : 소프트웨어 개발자가 설계했던과 다르게 동작하거나 다른 결과가 발생되는 것

1. 결함 관리 프로세스 처리 순서
   1. 결함 관리 계획
   2. 결함 기록
   3. 결함 검토
   4. 결함 수정
   5. 결함 재확인
   6. 결함 상태 추적 및 모니터링 활동
   7. 최종 결함 분석 및 보고서 작성
2. 결함 관리 측정 지표
   - 결함 분포 : 모듈 또는 컴포넌트의 특정 속성에 해당하는 결함 수 측정
   - 결함 추세 : 테스트 진행 시간에 따른 결함 수의 추이 분석
   - 결함 에이징 : 특정 결함 상태로 지속되는 시간 측정
3. 결함 추적 순서
   1. 결함 등록
   2. 결함 검토
   3. 결함 할당 : 문제 해결 개발자에게 결함이 할당된 상태
   4. 결함 수정 : 개발자가 결함 수정을 완료한 상태
   5. 결함 조치 보류 : 결함의 수정이 불가능해 연기된 상태
   6. 결함 종료 : 결함이 해결되어 종료를 승인한 상태
   7. 결함 해제 : 결함이 아니라고 판명한 상태
4. 결함 조치 상태
   - 열린 : 오류가 발견되었지만 분석되지 않은 상태
   - 할당된 : 오류가 개발자에게 할당된 상태
   - 연기된 : 우선순위가 낮아 잠시 미뤄진 상태
   - 종료된 : 수정되고 더 이상 오류가 발생되지 않는 상태
   - 수정된 : 개발자에 의해 오류가 수정된 상태
   - 분류된 : 오류 등록은 되었지만 분석결과 오류가 아님으로 결정난 상태

# *70. 애플리케이션 성능 분석

- 애플리케이션 성능 측정 지표
  - 처리량(Throughput)
  - 응답시간(Response Time)
  - 경과 시간(Turn Around Time)
  - 자원 사용률(Resource Usage)

# *71. 애플리케이션 성능 개선

1. 애플리케이션 성능 개선 방안(아품애 호소)
   - 아키텍처 조정 : Factory Method패턴
   - 소스코드 품질 분석 도구 : StringBuffer,Log4j
   - 애플리케이션 성능 현황 관리 : 성능 현황판(Q-Board)작성
   - 프로그램 호출 순서 조정 : 호출하는 함수 먼저 코딩
   - 소스 코드 최적화 기법 적용 : 개발 프레임워크 코딩 표준, 인터페이스를 통해 추상화된 자료 구조를 구현하여 의존성 최소화
2. 소스 코드 최적화 기법(가단의 중추)
   - 가독성
   - 단순성
   - 의존성 배제
   - 중복성 최소화
   - 추상화
3. 소스 코드 최적화 유형
   - 클래스 분할배치
   - Losely Coupled(느슨한 결합) : 인터페이스 클래스를 사용하여 추상화된 자료 구조와 메소드를 구현함으로써 클래스 간의 의존성을 최소화
   - 코딩 형식 준수
   - 좋은 이름 사용
   - 적절한 주석문 사용