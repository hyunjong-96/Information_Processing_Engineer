# 31. 데이터 모델의 개념

## 데이터모델의 정의

- 현실 세계의 정보들을 컴퓨터에 표현하기 위해 단순화하고 추상화하여 체계적으로 표현한 개념적 모형

--------------------------------

## 데이터 모델 구성 요소

- 개체 : DB에 표현하려는 것, 현실 세계의 대상체
- 속성 : 데이터의 가장 작은 논리적 단위, 데이터 필드에 해당
- 관계 : 개체 간의 관계 또는 속성 간의 논리적인 연결을 의미

---------------------------------

## 데이터 모델 종류

1. 개념적 데이터 모델 : 인간의 이해를 돕기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정.
   - E-R모델
2. 논리적 데이터 모델 : 개념적 모델링 과정에서 얻은 개념적 구조를 컴퓨터가 이해하고 처리할 수 있는 컴퓨터 세계의 환경에 맞도록 변환하는 과정
3. 물리적 데이터 모델 : 실제 컴퓨터에 데이터가 저장되는 방법을 정의하는 물리 데이터베이스 설계 과정

----------------------------------------

## 논리적 데이터 모델의 품질 검증

논리 데이터 모델의 품질은 논리 **데이터 모델 품질 기준**(정확성, 완전성, 준거성, 최신성, 일관성, 활용성)에 따라 체크리스트들을 확인

- 개체 품질 검증 항목
- 속성 품질 검증 항목
- 관계 품질 검증 항목
- 식별자 품질 검증 항목
- 전박적인 품질 검증 항목

-------------------------------------

## 데이터 모델에 표시할 요소

- 구조 : 논리적으로 표현된 개체 타입들 간의 관계로써 데이터 구조 및 정적 성질을 표현함
- 연산 : DB에 저장된 데이터들을 처리하는 작업에 대한 명세로써 DB를 조작하는 기본 도구
- 제약조건 : DB에 저장될 수 있는 실제 데이터의 논리적인 제약 조건

-------------------------------------

# 32. 이상/함수적 종속/정규화

## 이상

- 일부 속성들의 종속으로 인해 데이터 중복이 발생하여 테이블 조작시 문제가 생기는 현상

### 종류

- 삽입이상 : 원하지 않는 값들로 인해 삽입할수 없는 현상
- 삭제이상 : 의도와 상관없는 값들도 함꼐 삭제됨(연쇄 삭제)
- 갱신이상 : 일부 튜플의 정보만 갱신되어 정보의 불일치성이 생기는 현상

----------------------------

## 함수적 종속

- 속성 X의 값에 항상 속성 Y의 값이 하나만 연관되어 있을때 **Y는 X에 함수적 종속**, **X가 Y를 함수적으로 결정**
- X->Y
- X : 결정자, Y: 종속자
- **완전 함수적 종속** : 속성 집합에 대해서 함수적 종속일때.
- **부분 함수적 종속** :  속성 집합에 대해서 일부만 함수적 종속일떄.

------------------------------------

## 정규화

- 테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용해서 무손실 분해를 하는 과정.

---------------------------------

## 제 1정규형

- 비정규 릴레이션에서 도메인이 원자값일때

-------------------------

## 제 2정규형

- 제 1정규화
- 부분 함수적 종속 제거

-------------------

## 제 3정규형

- 제 2정규화
- 이행적 함수적 종속 제거

---------------------------------

## BCNF

- 모든 결정자가 후보키

----------------------------

## 제 4정규형

- 다치 종속 제거(복합 속성에 대응하는 속성이 복합 속성중 하나는 아예 관계없는 것)

-------------------------------

## 제 5정규형

- 모든 조인 종속(테이블의 부분집합들이 모두 조인한 결과가 동일)

------------------------------

# 33. 논리 데이터 모델의 물리 데이터 모델로 변환

## 엔티티를 테이블로 변환

| 논리적 데이터 모델 | 물리적 데이터 모델 |
| :----------------: | :----------------: |
|       엔티티       |       테이블       |
|        속성        |        컬럼        |
|     주 식별자      |       기본키       |
|    외부 식별자     |       외래키       |
|        관계        |        관계        |



--------------------------

## 슈퍼타입/서브타입을 테이블로 변환

1. 슈퍼타입 기준 테이블 변환
   - 서브타입에 속성이나 관계가 적을 경우
   - 장점
     - 데이터의 엑세스가 상대적으로 용이
     - SQL문장 구성이 단순해진다.
     - 여러 테이블을 조인하지 않아도 되므로 수행속도가 빨라진다.
   - 단점
     - 컬럼의 증가로 디스크 저장 공간이 증가
     - 인덱스 크기의 증가로 인덱스의 효율이 떨어진다.
     - 서브타입에 대한 구분이 필요한 경우가 많아진다.
2. 서브타입 기준 테이블 변환
   - 서브타입의 속성이나 관계가 많이 포함된 경우 적용.
   - 장점
     - 서브타입 속성들의 선택 사양이 명확한 경우 유리
     - 처리할때마다 서브타입 유형을 구분할 필요가 없다
     - 테이블당 크기가 감소하여 전체 테이블 스캔시 유리
   - 단점
     - 수행 속도 감소
     - 복잡한 처리를 하는 SQL의 통합이 어렵다
     - 식별자의 유지 관리가 어렵다.
     - 여러 테이블을 통합한 뷰는 조회만 가능하다
3. 개별타입 기준 테이블 변환
   - 슈퍼타입과 서비타입 테이블 사이에는 각각 1:1 관계가 형성
   - 서브타입의 처리가 대부분 독립적으로 발생하는 경우
   - 통합하는 테이블의 컬럼 수가 많은 경우
   - 서브타입의 컬럼 수가 많은 경우
   - 트랜잭션이 주로 슈퍼타입에서 발생하는 경우
   - 단일 테이블 클러스터링이 필요한 경우

------------------------------

## 속성을 컬럼으로 변환

- Primary UID를 기본키로 변환 : 논리데이터 모델의 식별자는 물리 데이터 모델의 기본키로 변환
- 관계의 UID Bar를 기본키로 변환 : 다른 엔티티와의 관계에 의해 만들어진 UID Bar는 물리 데이터 모델의 기본키로 만든다.
- Secondary UID를 유니크키로 변환

------------------------------

## 관계를 외래키로 변환

- 1:1
- 1:N
- N:M : 교차 엔티티(관계 테이블의 기본키)

------------------------------

## 관리 목적의 테이블/컬럼 추가

------------------------------

## 데이터 타입 선택

---------------------------------

# 34. 반정규화

# 35. 인덱스 설계

# 36. 뷰 설계

# 37. 클러스터 설계

# 38. 파티션 설계

# 39. 데이터베이스 용량 설계