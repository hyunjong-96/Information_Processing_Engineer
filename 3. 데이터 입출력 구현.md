# 31. 데이터 모델의 개념

## *데이터모델의 정의

- 현실 세계의 정보들을 컴퓨터에 표현하기 위해 단순화하고 추상화하여 체계적으로 표현한 개념적 모형

--------------------------------

## *데이터 모델 구성 요소

- **개체** : DB에 **표현하려는 것**, 현실 세계의 대상체
- **속성** : 데이터의 **가장 작은 논리적 단위**, 데이터 필드에 해당
- **관계** : 개체 간의 **관계** 또는 속성 간의 **논리적인 연결**을 의미

---------------------------------

## *데이터 모델 종류(개논물)

1. **개념적 데이터 모델** : 인간의 이해를 돕기 위해 현실 세계에 대한 **인식**을 **추상적 개념으로 표현하는 과정**.
   - E-R모델
2. **논리적 데이터 모델** : 개념적 모델링 과정에서 얻은 **개념적 구조**를 컴퓨터가 이해하고 처리할 수 있는 **컴퓨터 세계의 환경에 맞도록 변환하는 과정**
3. **물리적 데이터 모델** : 실제 컴퓨터에 **데이터가 저장되는 방법을 정의**하는 **물리 데이터베이스 설계 과정**

----------------------------------------

## 논리적 데이터 모델의 품질 검증

논리 데이터 모델의 품질은 논리 **데이터 모델 품질 기준**(정확성, 완전성, 준거성, 최신성, 일관성, 활용성)에 따라 체크리스트들을 확인

- 개체 품질 검증 항목
- 속성 품질 검증 항목
- 관계 품질 검증 항목
- 식별자 품질 검증 항목
- 전박적인 품질 검증 항목

-------------------------------------

## *데이터 모델에 표시할 요소(구연제)

- **구조** : **논리적으로 표현**된 **개체 타입들 간의 관계**로써 데이터 구조 및 정적 성질을 표현함
- **연산** : DB에 저장된 **데이터들을 처리하는 작업에 대한 명세**로써 DB를 조작하는 기본 도구
- **제약조건** : DB에 저장될 수 있는 실제 **데이터의 논리적인 제약 조건**

-------------------------------------

# *32. 이상/함수적 종속/정규화

## *이상

- 일부 속성들의 종속으로 인해 데이터 중복이 발생하여 테이블 조작시 문제가 생기는 현상

### 종류

- 삽입이상 : 원하지 않는 값들로 인해 삽입할수 없는 현상
- 삭제이상 : 의도와 상관없는 값들도 함꼐 삭제됨(연쇄 삭제)
- 갱신이상 : 일부 튜플의 정보만 갱신되어 정보의 불일치성이 생기는 현상

----------------------------

## *함수적 종속

- 속성 X의 값에 항상 속성 Y의 값이 하나만 연관되어 있을때 **Y는 X에 함수적 종속**, **X가 Y를 함수적으로 결정**
- X->Y
- X : 결정자, Y: 종속자
- **완전 함수적 종속** : 속성 집합에 대해서 함수적 종속일때.
- **부분 함수적 종속** :  속성 집합에 대해서 일부만 함수적 종속일떄.

------------------------------------

## *정규화(도부이결다조)

- 테이블의 속성들이 **상호 종속적인 관계를 갖는 특성**을 이용해서 **무손실 분해를 하는 과정.**

---------------------------------

## *제 1정규형

- 비정규 릴레이션에서 도메인이 원자값일때

-------------------------

## *제 2정규형

- 제 1정규화
- 부분 함수적 종속 제거
- 기본키에 대해 완전 함수적 종속이 되도록 테이블을 나눠야한다.
  ex) <주문> <u>주문번호</u>, 고객번호, 주소
  <주문목록> <u>주문번호</u>, <u>제품번호</u>, 주문수량 

-------------------

## *제 3정규형

- 제 2정규화
- 이행적 함수적 종속 제거
- 이행적 함수 종속(A->B이고 B->C이면 A->C이다)
- ex) 주문번호->고객번호
  고객번호->주소
  주문번호 -> 주소 는 옳지 않다.

---------------------------------

## *BCNF

- 모든 결정자가 후보키

- 결정자인데 후보키가 아닌것 제외

- ex) <수강_교수> <u>학번</u>, <u>과목명</u>, 담당교수 에서 함수적종속 담당교수->과목명이 존재하지만 담당교수가 후보키가 아니므로 BCNF가 아니다.

  =>
  <수강> <u>학번</u>, <u>담당교수</u>
  <교수>  <u>담당교수</u>, 학번 으로 분리해준다.

----------------------------

## *제 4정규형

- 다치 종속 제거(복합 속성에 대응하는 속성이 복합 속성중 하나는 아예 관계없는 것)

-------------------------------

## *제 5정규형

- 모든 조인 종속(테이블의 부분집합들이 모두 조인한 결과가 동일)

------------------------------

# 33. 논리 데이터 모델의 물리 데이터 모델로 변환

## 엔티티를 테이블로 변환

| 논리적 데이터 모델 | 물리적 데이터 모델 |
| :----------------: | :----------------: |
|       엔티티       |       테이블       |
|        속성        |        컬럼        |
|     주 식별자      |       기본키       |
|    외부 식별자     |       외래키       |
|        관계        |        관계        |



--------------------------

## 슈퍼타입/서브타입을 테이블로 변환

1. 슈퍼타입 기준 테이블 변환
   - 서브타입에 속성이나 관계가 적을 경우
   - 장점
     - 데이터의 엑세스가 상대적으로 용이
     - SQL문장 구성이 단순해진다.
     - 여러 테이블을 조인하지 않아도 되므로 수행속도가 빨라진다.
   - 단점
     - 컬럼의 증가로 디스크 저장 공간이 증가
     - 인덱스 크기의 증가로 인덱스의 효율이 떨어진다.
     - 서브타입에 대한 구분이 필요한 경우가 많아진다.
2. 서브타입 기준 테이블 변환
   - 서브타입의 속성이나 관계가 많이 포함된 경우 적용.
   - 장점
     - 서브타입 속성들의 선택 사양이 명확한 경우 유리
     - 처리할때마다 서브타입 유형을 구분할 필요가 없다
     - 테이블당 크기가 감소하여 전체 테이블 스캔시 유리
   - 단점
     - 수행 속도 감소
     - 복잡한 처리를 하는 SQL의 통합이 어렵다
     - 식별자의 유지 관리가 어렵다.
     - 여러 테이블을 통합한 뷰는 조회만 가능하다
3. 개별타입 기준 테이블 변환
   - 슈퍼타입과 서비타입 테이블 사이에는 각각 1:1 관계가 형성
   - 서브타입의 처리가 대부분 독립적으로 발생하는 경우
   - 통합하는 테이블의 컬럼 수가 많은 경우
   - 서브타입의 컬럼 수가 많은 경우
   - 트랜잭션이 주로 슈퍼타입에서 발생하는 경우
   - 단일 테이블 클러스터링이 필요한 경우

------------------------------

## 속성을 컬럼으로 변환

- Primary UID를 기본키로 변환 : 논리데이터 모델의 식별자는 물리 데이터 모델의 기본키로 변환
- 관계의 UID Bar를 기본키로 변환 : 다른 엔티티와의 관계에 의해 만들어진 UID Bar는 물리 데이터 모델의 기본키로 만든다.
- Secondary UID를 유니크키로 변환

------------------------------

## 관계를 외래키로 변환

- 1:1
- 1:N
- N:M : 교차 엔티티(관계 테이블의 기본키)

------------------------------

## 관리 목적의 테이블/컬럼 추가

------------------------------

## 데이터 타입 선택

---------------------------------

# *34. 반정규화

- **시스템의 성능 향상**, **개발 및 운영의 편의성** 등을 위해 **정규화된 데이터 모델을 통합, 중복, 분리하는 과정**으로, **의도적으로 정규화 원칙을 위배하는 행위**.
- 방법
  - 테이블 통합 : 두개의 테이블이 조인 되는 경우가 많아 하나의 테이블로 합쳐 사용하는 것이 성능에 도움이 될 경우 수행
  - 중복 테이블 추가 : **여러 테이블에서 추출해서 사용**해야하거나 **다른 서버에 저장된 테이블을 이용**해야 하는 경우 중복 테이블을 추가하여 작업의 효율성 향상
  - 중복 속성 추가 : 조인해서 데이터를 처리할 때 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 하나 더 추가.
  - 테이블 분할 
    - 수평 분할 : 레코드(수평)을 기준으로 **레코드별 사용 빈도의 차이**가 있을 경우 분할
    - 수직 분할 : 테이블에 **속성이 너무 많을 경우** 속성을 기준으로 분할



----------------------------------

# *35. 인덱스 설계

- 인덱스 : 데이터 레코드를 빠르게 접근하기 위해 **[키값, 포인터] 쌍으로 구성되는 데이터 구조**
- **클러스터드 인덱스** : 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식
- **넌클러스터드 인덱스** : 인덱스의 키 값만 정렬되어있을뿐 실제 데이터는 정렬되지 않는 방식

------------------------------------------------------

# *36. 뷰 설계

- 사용자에게 **접근이 허용된 자료만 보여주기 위해** 하나 이상의 테이블로 부터 유도된 **가상 테이블**
- 저장 장치에 물리적으로 존재하지 않지만, 사용자에게는 있는 것처럼 간주
- CREATE문으로 정의하고, DROP문으로 제거한다.
- 데이터의 논리적 독립성을 제공한다.

------------------------------------------------------

# *37. 클러스터 설계

- **클러스터** : 데이터 저장시 **액세스의 효율을 향상**시키기 위해 **동일한 성격의 데이터**를 **동일한 데이터 블록에 저장**하는 **물리적 저장 방식**
- 클러스터링키로 지정된 컬럼의 순서대로 저장되고 여러 개의 테이블이 하나의 클러스터에 저장.
- 클러스터링 된 테이블은 **데이터 조회속도 향상**, 하지만 **데이터 입력, 수정, 삭제에 대한 성능은 저하**
- 처리 범위가 넓은 경우 **단일 테이블 클러스터링**, 조인이 많이 발생할 경우 **다중 테이블 클러스터링** 사용

------------------------------------------------------

# *38. 파티션 설계

- **파티션** : 대용량의 테이블이나 인덱스를 작은 논리적 단위로 나누는 것.
- **인덱스 파티션** : 파티션된 테이블의 데이터를 관리하기 위해 인덱스를 나누는 것.
- 파티셔닝 방식에 따른 파티션 종류(**범해조**)
  - **범**위 분할 : **지정한 열의 값을 기준**으로 분할
  - **해**시 분할 : **해시 함수를 적용한 결과 값**에 따라 데이터를 분할
  - **조**합 분할 : **범위 분할**로 분할한 다음 **해시 함수**를 적용하여 다시 분할

------------------------------------------------------

# 39. 데이터베이스 용량 설계

------------------------------------------------------

# *40. 트랜잭션

- 데이터베이스의 **상태를 변환**시키는 **하나의 논리적 기능을 수행**하기 위한 **작업의 단위**.
- 특징(**원일지독**)
  - **원**자성(Automicity) : 트랜잭션의 연산은 데이터베이스에 **모두 반영**되던지 **전혀 반영되지않아야** 한다. 
  - **일**관성(Consistency) : 트랜잭션이 실행을 성공하면 **일관성 있는 데이터베이스 상태로 변환**함
  - **지**속성(Isolation) : 하나의 트랜잭션이 실행중일 떄는 **다른 트랜잭션의 연산이 끼어들수 없음**.
  - **독**립성(Durability) : 완료된 트랜잭션의 **결과는 시스템이 고장나더라도 영구적으로 반영**되야 함.