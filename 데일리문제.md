# 1.요구사항 확인

1. 소프트웨어 아키텍처 4+1뷰(**논구**는 **배프 유**)
   - **논**리뷰
   - **구**현뷰
   - **배**포뷰
   - **프**로세스뷰
   - **유**스케이스뷰
2. 요구사항 개발 프로세스(**도분명확**)
   (1) 요구사항 **도**출
   (2) 요구사항 **분**석
   (3) 요구사항 **명**세
   (4) 요구사항 **확**인
3. **프로토타이핑**
   // 사용자가 요구한 기능 등 소프트웨어의 전체 기능을 수행할수 있는 시제품을 만드는 과정
4. OSI 7계층
   - 7계층(응용 계층) - 데이터
   - 6계층(표현 계층) - 데이터
   - 5계층(세션 계층) - 데이터
   - 4계층(전송 계층) - 세그먼트
   - 3계층(네트워크 계층) - 패킷
   - 2계층(데이터링크 계층) - 프레임
   - 1계층(물리 계층) - 비트
5. tpmC
   - 특정 서버에서 자체 테스트를 수행하여 나온 결과중 **1분간 최대 처리건수**를 나타낸 수치
   - **가장 객관적으로 하드웨어 성능을 나타내는 수치**
6. 인터페이스
   - JDBC 
     //**자바**에서 DB를 사용하도록 연결해주는 응용 프로그램 인터페이스
   - ODBC
     //DB를 엑세스하기 위한 **표준 개방형** 응용프로그램 인터페이스
7. 요구사항 분석 기법(**분개할 협상**)
   - 요구사항 **분**류 : 기능인지 비기능인지
   - **개**념적 모델링 : 문제 도메인의 엔티티와 개별관계 및 종속성 반영
   - 요구사항 **할**당 : 아키텍처 구성 요소 식별
   - 요구사항 **협**상 : 이해관계자 합의
   - **정**형분석 : 요구사항 분석의 마지막 단계
8. 개념모델링
   - 문제 도메인의 엔티티와 개별관계 및 종속성 반영
   - 시나리오로 나타내기 위해 **유스케이스 다이어그램**을 주로 사용
   - 모델링 표기법은 **UML**
9. UML의 관계
   - **집합관계** : 하나의 사물이 다른 사물에 포함되어 있는것(독립적)
     //포함되는 쪽에서 포함하는 쪽(전체)로 빈 마름모
     //학생 <- 가방
   - **합성 관계** : 하나의 사물이 다른 사물에 필수적으로 포함되어있는것(의존적)
     //포함되는 쪽에서 포함하는 쪽(전체)으로 찬 마름모
     //자동차 <- 엔진
   - **실체화 관계** : 사물이 할수 있거나 해야하는 기능으로써 서로를 그룹화 할수 있는 관계(Can do this)를 표현
     //기능쪽으로 빈 점선 화살표 연결
10. 디자인 패턴
    - **Factory Method** 패턴
      //상위 클래스에서 객체를 생성하는 인터페이스 정의, 하위 클래스에서는 인스턴스를 생성하도록 하는 방식
      //상위 클래스의 함수를 하위 클래스에서 오버라이딩하여 인터페이스와 실체 객체를 생성하는 클래스를 분리할수 있는 특성을 갖는 디자인패턴
    - **Singleton** 패턴
      //전역변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체는 어디에서든지 창조할수 있도록 하는 디자인 패턴
11. UML
    - 시퀀스 다이어그램
      //동작에 참여하는 객체들이 주고 받는 메시지를 표현
    - 커뮤니케이션 다이어그램
      //동작에 참여하는 객체들이 주고 받는 메시지 표현 및 객체 간의 연관관계까지 표현하는 다이어그램
    - 상태 다이어 그램
      //하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호작용에 따라 상태가 어떻게 변하는지 표현하는 다이어그램.
12. UML스테레오 타입
    - << include >> : 하나의 유스케이스가 어떤 시점에 반드시 다른 유스케이스를 실행하는 포함관계
      // 의뢰하는 쪽 --> 실행하는 쪽
    - << extend >> : 하나의 유스케이스가 어떤 시점에 다른 유스케이스를 실행할수 있고, 그렇지 않을수도 있는 확장관계
      //의뢰하는 쪽 <-- 실행하는 쪽

# 2.데이터입출력구현

1. **이상현상**

   //데이터의 중복성으로 인해 릴레이션을 조작할때 발생하는 비합리적인 현상

2. **프로시저**
   //SQL을 이용하여 생성된 데이터를 조작하는 프로그램

3. 데이터 조작 프로시저(**프함패트**)

   - 저장된 **프**로시저 : 복잡한 트랜잭션을 수행하는 PL/SQL문을 DB에 저장하는 기능 제공 프로그램
   - 저장된 **함**수 : 실행결과를 되돌려 받을수 있는 프로그램
   - 저장된 **패**키지 : 프로시저나 함수를 효과적으로 관리하기 위해 패키지 단위로 배포할때 사용하는 프로그램
   - **트**리거 : 특정 테이블에 삽입,수정,삭제 등의 변경 이벤트 발생시 DBMS에서 자동으로 실행되도록 구현된 프로그램.
   
4. 데이터베이스 설계(**요개논물구**)

   - **요**구사항 분석 : 정보 내용 및 요구수집, 경영목표 및 제약조건 식별, 요구명세서 작성 및 검토
   - **개**념적 설계 : DBMS독립적 개념스키마 설계, 트랜잭션 모델링, view통합방법 고려, Attribute합성
   - **논**리적 설계 : 목표DBMS에 맞는 스키마 설계, 트랜잭션I/F설계, 스키마 평가 및 정제
   - **물**리적 설계 : 목표 DBMS에 맞는 물리적 구조 설계, 트랜잭션 세부설계, 저장 레코드 양식 설계, 레코드 집중 분석 및 설계
   - **구**현 : 데이터베이스 생성, 트랜잭션 생성

# 3.통합구현

1. EAI구축 환경
   - EAI(Enterprise Application Integration)-연계솔루션(간접 연계 방식 기술)
     //기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션 간의 정보 전달, 연계 등을 가능하게 해주는 솔루션
   - **Point-to-Point**
     - 중간에 미들웨어 없이 각 애플리케이션간 연결
     - 특징
       - 솔루션 구매 없이 통합
       - 변경, 재사용 어려움
       - 상대적으로 저렴
   - **Hub & Spoke**
     - 허브 시스템을 통해 데이터를 전송하는 중앙 집중형 방식
     - 특징
       - 모든 데이터 전송 보장
       - 허브 장애 시 전체 영향
       - 확장, 유지보수 용이
   - **Message Bus(EBS)**
     - 애플리케이션 사이 미들웨어(버스)를 두어 처리
     - 특징
       - 뛰어난 확장성, 대용량 처리 가능
   - **Hybride**
     - 그룹 내에는 Hub&Spoke방식, 그룹 간에는 Messsage Bus방식
     - 특징
       - 표준 통합 기술
       - 데이터 병목 현상 최소화
2. 연계메커니즘
   - 직접연계
     - DB링크
     - DB연결
     - OpenAPI
     - JDBC
     - 하이퍼링크
   - 간접연계
     - 연계솔루션(EAI)
     - Web Server
     - 소켓
3. 상향식 통합 테스트의 절차 나열
   (1) **모듈 또는 컴포넌트가 하위 모듈 기능을 수행하는 클러스터로 통합**
   (2) **드라이버라는 제어프로그램 작성**
   (3) **각 통합된 클러스터 단위 테스트**
   (4) **각 클러스터들은 프로그램의 위쪽으로 결합, 드라이버는 실제 모듈 또는 컴포넌트로 대체**.
4. 요구사항 분석 기법
   - 체크리스트 : 기준에 대한 **점검**을 통한 분석기법
   - 브레인스토밍 : 자발적으로 **자연스럽게** 제시된 **아이디어 목록**을 통해 분석하는 기법
   - 델파이 : **전문가 경험**
   - 인터뷰 : 사용자 면담
   - 설문지 : 설문지 분석

# 4.서버프로그램구현

1. 응집도
   - **우**연적 응집도 : 뚜력한 관계x
   - **논**리적 응집도 : 논리적으로 유사한 기능
   - **시**간적 응집도 : 특정시간
   - **절**차적 응집도 : 순서대로 수행
   - **통**신적 응집도 : 동일한 입출력 자료, 다른 기능
   - **순**차적 응집도 : 한 요소의 출력자료가 다른 요소의 입력자료
   - **기**능적 응집도 : 모듈 내 모든 요소들이 단일 기능 수행
2. 결합도
   - **내**용 결합도
   - **공**통 결합도 : 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용하는 경우의 결합도
   - **외**부 결합도 : 두 개의 모듈이 외부에서 도입된 데이터 포맷, 통신 프로토콜, 또는 디바이스 인터페이스를 공유할 경우의 결합도
   - **제**어 결합도
   - **스**탬프 결합도
   - **자**료 결합도
3. 프레임워크의 특징(**모확재제**)
   - **모**듈화 : 인터페이스에 의한 캡슐화를 통해 모듈 강화, 변경에 대한 영향 극소화
   - **확**장성 : 다형성을 통해 인터페이스를 넓게 사용가능
   - **재**사용성 : 반복적으로 사용될수 있는 컴포넌트의 정의로 재사용성 높아짐, 개발자의 생산성 높아짐
   - **제**어의 역흐름 : 제어가 프레임워크로부터 애플리케이션으로 반대로 흐르게 된다.
4. 모듈화 측정 척도
   - **fan-in** : 참조하는 모듈 갯수(들어오는 화살표 갯수)
   - **fan-out** : 참조되는 모듈 갯수(나가는 화살표 갯수)

# 5.인터페이스구현

1. 인터페이스 구현 도구
   - **xUnit** : 다양한 언어지원
     //Java(JUnit),C++(CppUnit),.Net(NUnit)등 다양한 언어를 지원하는 단위 테스트 프레임워크
     //SW의 함수나 클래스 같은 서로 다른 구성 원소를 테스트 할 수 있게 해주는 테스트 도크
   - **STAF** : 다양한 환경지원 및 재사용 및 확장성
     //서비스호출, 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크
   - **Fitnesse** : 웹 기반 테스트 케이스 설계 등 지원 및 협업 기능
   - **NTAF** : Fitnesse의 장점인 협업 기능과 STAF의 장점인 재사용 및 확장성을 통합한 NHN(NAVER)의 테스트 자동화 프레임워크
   - **Selenium** : 다양한 브라우저 지원 및 개발언어를 지원하는 웹 애플리케이션 테스트 프레임워크, 테스트 스크립트 언어를 학습할 필요없이 기능 테스트를 만들기 위한 도구 제공
   - **watir** : 루비 기반
   - **SCOUTER** : 애플리케이션에 대한 모니터링 및 DB Agent를 통해 오픈소스 DB모니터링 기능, 인터페이스 감시기능을 제공하는 도구.
2. 인터페이스 연계 시 적용할 수 있는 보안 프로토콜
   - **SSL/TLS**
     //전송계층과 응용계층 사이에서 클라이언트와 서버간의 웹 데이터 암호화(기밀성), 상호인증 및 전송시 데이터 무결성을 보장하는 보안 프로토콜
   - **S-HTTP(Secure Hypertext Transfer Protocol)**
     //웹 상에서 네트워크 트래픽을 암호화하는 주요 방법 중 하나
     //클라이언트와 서버간에 전송되는 Http를 사용하는 애플리케이션에 한해서 모든 메시지를 암호화하여 전송하는 보안 프로토콜
   - S-HTTP와 HTTPS차이
     //암호화 방식의 차이
     //S-HTTP는 SSL을 사용하지 않고 HTTP와 같은 포트를 사용하면서 message단위로 암호화

# 6.화면설계

1. UI설계 기본 원칙(**직유학유**)
   - **직**관성 : 누구나 쉽게 이해하고, 쉽게 사용할수 있어야 한다.
   - **유**효성 : 정확하고 완벽하게 사용자의 목표가 달성될수 있도록 제작.
   - **학**습성 : 초보와 숙련자 모두가 쉽게 배우고 사용할수 있도록 제작.
   - **유**연성 : 사용자의 인터렉션을 최대한 포용하고, 실수를 방지할 수 있도록 제작.
2. **스토리보드**
   - 구축하는 서비스에 대한 대부분의 정보가 수록된 문서
   - 디자이너와 개발자가 최종적으로 참고하는 산출 문서
3. UI품질 요구사항(**기신사 효유이**)
   - **기**능성
   - **신**뢰성
   - **사**용성(**사이학운**)
     - **이**해성 : SW의 논리적인 개념과 적용가능성을 분간.
     - **학**습성 : 애플리케이션을 익히는데 필요한 사용자의 노력 정도.
     - **운**용성 : SW활용과 운용통제에 필요한 사용자의 노력 정도.
   - **효**율성
   - **유**지 보수성
   - **이**식성
4. 웹의 3요소(**표접호**)
   - 웹 **표**준
   - 웹 **접**근성
   - 웹 **호**환성
5. WCAG 2.0의 원칙(웹접근성)(웹 접근에 **이견인**는 사람은 **운**다)
   - **이**해성 : 가독성, 예측가능성, 입력 지원의 세부지침이 있다.
   - **견**고성 : 호환성의 세부지침
   - **인**식의 용이성 : 대체 테스트, 실시간 미디어 대체수단, 융통성, 식별성이 세부지침에 있다.
   - **운**용의 용이성 : 키보드 접근성, 충분한 시간 제공 및 시간조절 기능, 발작 예방, 탐색 가능성의 세부지침이 있다.
6. UI시나리오 문서 작성의 요건(**완일이가 추수**)
   - **완**전성
     //시스템보다 사용자의 태스크에 초점을 맞춰야한다
     //UI시나리오는 누락이 없어야하고 최대한 빠짐없이 상세하게 기술
   - **일**관성
     //서비스에 대한 목표, 시스템 및 사용자의 요구사항이 일관성 있어야 한다.
   - **이**해성
     //처음 접하는 사용자도 이해하기 쉽도록 구성하고 설명해야한다.
   - **가**독성
     //문서를 쉽게 읽을수 있어야 하고 표준화된 템플릿을 작성하여 적용한다.
   - **추**적 용이성
     //변경사항들이 언제,어디서,왜 발생하였는지 추적이 쉬워야 한다.
   - **수**정 용이성
     //시나리오에 반영함에 있어 쉽게 적용할수 있어야한다.

# 7.애플리케이션 테스트 관리

1. 통합테스트
   - **드라이버** : 상향식 통합 테스트에서 사용하는 더미모듈로 상위모듈에서 데이터의 입력과 출력을 하기 위한 더미 모듈
   - **스텁** : 하향식 통합 테스트에서 사용하는 더미모듈로 하위 컴포넌트를 대신하는 더미모듈.
   - **빅뱅테스트** : 모든 모듈을 한번에 통합후 테스트, 종료시점에 한번 테스트
   - **혼합식 통합 테스트(샌드위치 테스트)** : 테스트 하위 수준에서는 상향식 통합테스트, 테스트 상위 수준에서는 하향식 통합테스트.
2. **단위 테스트**
   - 사용자 요구사항에 대한 단위 모듈, 서브루틴 등을 테스트하는 단계
   - 종류(**인자실오**)
     - **인**터페이스 테스트
     - **자**료구조 테스트
     - **실**행 경로 테스트
     - **오**류 처리 테스트
3. 테스트 레벨(**단통시인**)
   - **단**위 테스트
   - **통**합 테스트
   - **시**스템 테스트
   - **인**수 테스트
4. 결함 우선순위
   - 결정적
   - 높음
   - 보통
   - 낮음
5. 결함 조치 상태
   - **열린** : 오류가 발견되었지만 분석되지 않은 상태
   - **할당된** : 오류가 개발자에게 할당된 상태
   - **연기된** : 우선순위가 낮아 잠시 미뤄진 상태
   - **종료된** : 수정되고 더 이상의 오류가 발생되지 않는 상태
   - **수정된** : 개발자에 의해 오류가 수정된 상태
   - **분류된** : 오류 등록은 되었지만 분석결과 오류가 아님으로 결정난 상태
6. 목적에 따른 테스트 종류(**회**와 **안성**탕면의 조합을 **강구**하기 위해서 **회**를 **병**째 먹었다)
   - **회**복 테스트 : 결함을 주고 얼마나 빠르게 회복하는지
   - **안**전 테스트 : 불법적인 침입으로부터 시스템을 보호할수 있는지
   - **성**능 테스트 : 응답 시간, 처리량 테스트
   - **강**도 테스트 : 과도한 정보량을 부과하여 과부화에도 정상적인 실행을 하는지
   - **구**조 테스트 : 논리적인 경로, 코드 복잡도 테스트
   - **회**귀 테스트 : 수정된 코드에서 새로운 결함이 없음을 확인
   - **병**행 테스트 : 기존sw와 수정된sw에 동일한 입력값을 주고 비교
7. 커버리지 테스트
   - **구문** 커버리지 : 전체 구문 실행
   - **조건** 커버리지 : 내부 조건 True,False한번 씩 실행
   - **결정** 커버리지 : 전체 결과 True,False한번 씩 실행
   - **조건/결정** 커버리지 : 내부조건과 전체 결과가 True,False한번씩
8. 애플리케이션 테스트 관리
   - 화이트박스 테스트와 블랙박스 테스트의 수행순서는 **결함 검출률과 관계없다**
   - 리그레이션(회귀)테스트는 반복성향 때문에 **자동화 테스트에 적합**
   - 디버깅은 **개발활동**
   - 타 시스템과 연동 테스트는 **통합 테스트 단계**
9. 애플리케이션 성능 개선 방안(**아품애 호소**)
   - **아**키텍처 조정 : FactoryMethod 패턴
   - 소스코드 **품**질 분석 도구 : StringBuffer,StringBuffer클래스, Log4j
   - **애**플리케이션 성능 현황 관리 : 성능 현황판(Q-Board) 작성
   - 프로그램 **호**출 순서 조정 : 호출하는 함수 먼저 코딩
   - **소**스 코드 최적화 기법 적용 : 개발 프레임워크의 코딩 표준, 인터페이스를 통해 추상화된 자료구조를 구현하여 의존성 최소화.
10. 소스코드 최적화 기법(**클린코드 작성원칙**)(**가단의 중추**)
    - **가**독성 : 이해하기 쉬운 용어 사용
    - **단**순성 : 한번에 한가지의 기능만 처리
    - **의**존성 : 코드의 변경이 다른 코드에 영향이 가지 않도록.
    - **중**복성 : 중복 코드 제거
    - **추**상화 : 동일한 수준의 추상화 구현, 상세 내용은 하위 클래스에서 구현
11. 소프트웨어 테스트의 원리
    - **완벽한 테스트는 불가능**
    - **개발 초기에 테스팅 시작**
    - **결함집중** : 80%의 결함은 20%에 집중되어있다.
    - **살충제 페러독스** : 똑같은 테스트케이스를 반복하면 새로운 결함을 찾을수 없다.
    - **테스팅은 정황에 의존적** : 소프트웨어 성격에 맞게 테스트 실시
    - **오류-부재의 궤변** : 요구사항이 충족되지 못하면, 결함이 없어도 품질이 좋지못하다.

# 8.SQL응용

# 9.소프트웨어 개발 보안 구축

1. 보안약점(**입보시에코캡아**)
   - **입**력데이터 검증 및 표현 : SQL삽입, 크로스 사이트 스크립트(XSS)
   - **보**안기능 : 인증,권한 관리, 암호화
   - **시**간 및 상태 : Race Condition, 무한루프
   - **에**러 처리 : 오류메시지로 정보노출, try-catch
   - **코**딩 오류 : 널 포인터 역참조, 자원 해제, 초기화
   - **캡**슐화 : 잘못된 세선에 의한 노출, 제거되지 않은 디버깅 코드
   - **A**PI오용 : 안전하지 않은 함수, DNS에 의존적
2. SW개발 보안3대 요소(**기무가**)
   - **기**밀성 : 시스템 내의 자원과 정보는 인가된 사용자만 사용가능.
   - **무**결성 : 인가된 사용자에 의해서만 수정이 가능하다.
   - **가**용성 : 인가받은 사용자는 언제든지 사용할 수 있다.
3. **스턱스넷(Stuxnet)**
   - 2010년에 발견된 웜 바이러스
   - **지멘스의 SCADA시스템**을 감염
   - **PLC**를 감염시켜 장비동작 변경
4. **다크데이터(DarkData)**
   - 정보를 수집후, 저장만 하고 분석에 활용하고 있지 않는 다량의 데이터
   - 방치되고 있는 데이터는 저장 공간만 차지하고 위험을 초래할수 있다.
5. **킬 스위치(kill switch)**
   - 잃어버린 스마트폰을 주은 사람이 해당 폰을 이동통신망 또는 와이파이에 접속하면 폰 주인이 원격으로 분실 기기를 사용불능하도록 만듦
   - 워너크라이 랜섬웨어가 퍼질때 워너크라이 내의 도메인을 정식으로 등록하면서 랜섬웨어를 만았을떄 킬스위치라고 불림.
6. **API(Advanced Persistent Threat)**
   - 특수 목적을 가진 조직이 하나의 표적에 대해 IT기술을 이용해 지속적으로 정보 수집
   - 취약점을 파악해 침투,검색,수집,유출하는 기법
7. 재해 관련 보안
   - **BCP(Business continuity Planning)**
     //기업이 재난이나 재해로 타격을 입은 뒤 업무를 어떻게 복구할것인지에 대한 계획.
     //전산 복구 뿐만 아니라 고객 비즈니스의 지속성을 보장한다.
   - **DRS**
     //재해나 재난시 서비스 연속성을 보장하기 위해 메인 센터와 분리되어 동일한 역할을 하는 재해 복구 시스템
   - **RTO(Recovery Time Objective)**
     //재해 복구 목표 시간
     //중요한 서비스일 수록 시간이 짧아야함.
8. **크라임 웨어(CrimeWare)**
   - 온라인 상에서 **불법활동을 조장**하기 위해 만들어진 프로그램
   - 공격용 툴킷이라고 불림
   - 인터넷에서 곧바로 사용할수 있으며 **키로거를 은밀히 설치 시켜 불법적으로 정보 수집**
9. 보안 공격 기법
   - **Smurf** : 브로드 캐스트하여 타겟 마비
   - **RUDY** : 바디부분을 소량으로 보내 자원을 고갈
   - **티어드롭** : IP Fragment offset을 중첩하여 수신자가 재조합하는 과정에서 오류.
10. 소프트웨어 개발 보안
    - **SSO**(Single Sign On)
      //인증 시스템의 하나, 한번의 인증을 통해서 여러 개의 서비스를 이용할수 있는 시스템.
11. IPSEC의 세부 프로토콜
    - **IKE**(Internet Key Exchange)
      //보안 관련 설정들을 생성, 협상 및 관리하는 프로토콜로 udp500번 포트를 사용하는 프로토콜
    - **AH**(Authentication Header)
      //기밀성(암호화)을 제외한 메시지 인증코드(MAC)를 이용한 인증(무결성),송신처 인증을 제공해주는 프로토콜
    - **ESP**(Encapsulating Security Payload)
      //메시지 인증코드(MAC)와 암호화를 이용하여 인증(무결성),송신처 인증, 기밀성을 제공하는 프로토콜
12. **버퍼플로우**
    - 버퍼플로우
      //정해진 메모리의 범위를 넘치게해 원래 리턴 주소를 변경시켜 임의 프로그램이나 함수를 실행시키는 시스템 해킹 기법
    - 버퍼플로우 대응방안
      - 운영체제의 주기적인 최신 패치 적용
      - 입력값 검증이 가능한 안전한 함수 사용(**strncpy()**)
      - **스택가드(StackGuard)**
        //카나리(carnary)라고 불리는 무결성 체크용 값을 복귀 주소와 변수 사이에 삽입해 두고 버퍼 오버플로우시 카나리의 값이 변하게 된다면 복귀주소를 호출하지 않는 방법.
      - **스택쉴드(StackShield)**
        //함수 시작시 복귀주소를 Global RET이라는 특수 스택에 저장해 두고 함수 종료시 저장된 값과 RET스택의 값을 비교하여 다를 경우 오버플로우로 간주하고 프로그램 종료
      - **ASLR(Address Space Layout Randomization)**
        //메모리의 공격을 벙어하기 위해 주소 공간 배치를 난수화하고, 실행 마다 메모리 주소를 변경시켜 버퍼 플로우를 통한 특정 주소 호출을 차단하는 방법.
13. SW개발 보안 용이
    - **자산**(Assert) : 조직의 데이터 또는 소유자가 **가치를 부여한 대상**
    - **위협**(Threat) : 조직이나 기업의 **자산**에 **악영향을 기칠수 있는 사건이나 행위**
    - **위험**(Risk) : 취약점을 이용하여 **자산의 손실 또는 피해를 가져올 가능성**.
14. 보안공격 기법
    //입력데이터 검증 및 표현(보안약점)의 공격기법
    - **XSS**(Cross Site Scripting)
      //검증되지 않는 데이터가 포함된 웹페이지가 전송되는 경우, 사용자가 해당 웹페이지를 열람함으로써 웹페이제 포함된 부적절한 스크립트가 실행되는 공격기법
    - **SQL**삽입
      //악의적인 SQL을 삽입,실행시켜 DB의 접근을 통해 정보를 탈취하거나 조작등의 행위를 하는 공격기법.
    - **CSRF**(Cross Site Request Forgery)
      //사용자가 자신의 의지와 다르게 공격자가 의도한 행위(수정,삭제,등록)를 웹사이트에 요청하게 하는 공격 기법.
15. 비밀키 암호화 알고리즘
    - **AES**(Advanced Encryption Standard)
      //고급암호화 표준이라고 불리는 암호화 알고리즘
      //블록크기는 128비트, 키 길이에 따라 128,192,256비트로 분류할수 있다
      //암호화 복호화 과정에서 동일한 키를 사용하는 대칭 키 알고리즘
    - **SEED**
      //KISA,ETRI에서 개발하고 TTA에서 인증한 안전성,신뢰성이 우수한 고속 블록단위의 128비트 대칭키 암호화 알고리즘
    - **DES**(Data Encryption Standard)
      //56bit의 키를 사용
      //64bit의 평문 블록을 64bit의 암호문 블록으로 만드는 블록 방식의 암호화 알고리즘

# 10.프로그래밍 언어 활용

1. 프로그래밍 언어

   - 알골(ALGOL) : 알고리즘 연구 개발 목적 언어(**알고리즘 -> 알골**)
   - 리스프(LISP) : 수학 표기법을 나타내기위한 목적 언어(**수학->리스프**)
   - 프롤로그(Prolog) : 논리식 기반으로 객체간의 문제 해결(**논리->Pro-logical**)
   - 하스겔(Haskell) : 함수형 프로그래밍언어, 코드간결, 에러 적음(**함수->ㅎㅅ->하스겔**)

2. C++ switch문

   ```c++
   switch 문에서 break 가 없다면 연속으로 case 문이 출력된다.
   std::cout<<"수";는 줄 바꿈없고 띄어쓰기 없다.
   std::cout<<"수"<<std::endl; 은 줄 바꿈.
   ```

3. **자료구조**

   - 컴퓨터에 데이터를 삽입,삭제,수정 할수 있게 해주는 **논리적인 공간구조**
   - 자료의 형태에 따라 단순구조, 선형구조, 비선형 구조, 파일 구조로 분류

4. 사용자 정의 자료형

   - **구조체(Structure)** : 사용자가 기본타입을 가지고 새롭게 정의할 수 있는 사용자 정의 자료형.
   - **열거형(Enumeration)** : 서로 연관된 정수형 상수들의 집합, 상수에 이름을 붙혀 코드 이해도움.
   - **공용체(Union)** : 모든 멤버 변수가 하나의 메모리 공간을 공유하는 사용자 정의 자료형.
   
5. 파이썬 타입

   ```python
   a={'일본','중국','한국'}
   a.add('베트남') //베트남추가
   a.add('중국')	//중국은 중복값이므로 무시
   a.remove('일본')	//일본제거
   a.update({'홍콩','한국','태국'})	//기존값에 있다면 무시, 없으면 추가, 홍콩,태국 추가
   print(a)	//{'중국','한국','베트남','홍콩','태국'}
   ```

   - 파이썬의 타입

     | 자료형     | 설명                                                         | 문법 예시                                                    |
     | ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
     | 리스트형   | 리스트 안에서는 어떠한 자료형도 포함시킬 수 있습니다.        | 리스트명=[요소1,요소2]<br />ex) test=[1,2,'한국']            |
     | 튜플형     | 리스트는 그 값의 생성, 삭제, 수정이 가능하지만 튜플은 그 값을 바꿀수 없는 특성을 제외하고는 리스트형과 비슷 | 튜플명=(요소1,요소2)<br />ex) test=(1,2,'한국')              |
     | 세트형     | 집합에 관련된 것을 처리하기 위해 만든 자료형                 | 세트명 = set([요소1,요소2,...])<br />세트명={요소1,요소2,...}<br />ex) a={'일본','중국','한국'} |
     | 딕셔너리형 | 대응 관계를 나타내는 자료형                                  | 딕셔너리명={키1:값1,키2:값2}<br />ex) test={1:"가",2:"나"}   |

6. c++ 생성자, 소멸자

   ```c++
   ﻿#include <iostream>
   using namespace std;
   class A{
   public:
     A( ){
       cout << "A" << endl;
     };
     A(int a){
       cout << "B" << endl;
     };
     ~A( ){
       cout << "C" << endl;
     };
     void fn( ){
       cout << "D" << endl;
     }
   };
   
   void main( ){
     A a = A(5);
     a.fn( );
   }
   ```

   - main메소드에서 A클래스의 파라미터 5를 가지고 있는 생성자를 호출(생성자) => C
   - a.fin()호출 => D
   - main메소드가 종료(소멸자) => D

7. 포인터 생성자

   ```c++
   #include <iostream>
   using namespace std;
   class A{
   public:
     A( ){
       cout << "A" << endl;
     };
     A(int a){
       cout << "B" << endl;
     };
     ~A( ){
       cout << "C" << endl;
     };
     void fn( ){
       cout << "D" << endl;
     }
   };
   
   void main( ){
     A *a = new A(5);
     a->fn();
   }
   ```

   - A *a 라고하면 A 클래스를 저장하고 있는 공간을 가리키는 a라는 이름의 포인터 변수를 만듬
   - 포인터 변수(a)에 new로 메모리를 할당해주었으면 delete로 메모리를 해제해야한다, 하지만 이 코드에서는 delete를 따로 해주지 않았기떄문에 프로그램을 종료해도 메모리는 할당되있는 상태(메모리 누수)
   - delete a를 선언해주어야 메모리 누수가 적용되지않는다.
   - A *a = new A(5);로 생성자를 만들었을때 함수를 불러올떄 a->fn();
   - 정답 : B, D

8. 파이썬 생성자, 소멸자

   ```python
   class A:
     def __init__(self):
       print("생성자")
     def __del__(self):
       print("소멸자")
   
   a = A()
   del a
   ```

9. 파이썬 연산자

   ```python
   print(2**3) //2^3
   print(3**2) //3^2
   ```

10. c출력

    ```c
    "%.2f" //소수점자리 둘째자리까지 출력
    ```

    

# 11.응용SW기초 기술 활용

1. **계층형 데이터베이스**

   - 데이터를 상하 종속 관계로 계층화 하여 관리하는 데이터베이스
   - 데이터에 대한 접근은 빠르지만, 변화하는 데이터 구조에 유연하게 대응하기 쉽지않다.

2. 라우팅 프로토콜(**BORI=보리**)

   - **R**IP : 최초 라우팅 프로토콜, 라우팅 루프 발생가능
   - **I**GRP : RIP업그레이드
   - **B**GP : 가장 규모가 큰 네트워크
   - **O**SPF : 링크 상태 알고리즘

3. **게이트웨이(GateWay)**
   //전송계층
   //프로토콜은 다른 통신장치에 접속할 수 있게 해주는 장치
   //데이터를 보내거나 받는 출입구 역할

4. 네트워크 전송기술

   - **유니 캐스트** : 1대1 데이터 전송
   - **애니 캐스트** : 단일 송신자 -> 가장 가까운 노드
   - **멀티 캐스트** : 다대다 데이터 전송
   - **브로드 캐스트** : 단일 송신자 -> 모든 수신자

5. 데이터베이스 기초 활용

   - **차수(degree)** : 하나의 릴레이션에서 **속성**의 개수
   - **카디너리티(cardinality)** : 하나의 릴레이션에서 **튜플**의 개수

6. 프로세스 스케줄링 알고리즘

   (1)**선점형** : 현재 실행중인 프로세스가 있을때 다른 프로세스의 우선순위가 높을때 현재 실행중인 프로세스를 중지

   - **라운드로빈(Round Robin)** : 시간 할당량, 시간안에 완료못하면 뒤로 보냄
   - **SRT(Shortest Remaining Time First)** : 가장 짧은 처리 우선 수행
   - **다단계 피드백 큐** : RR + FCFS, 우선순위 단계

   (2)**비선점형** : 현재 실행중인 프로세스가 있을때 다른 프로세스는 CPU점유 불가능

   - **우선순위** : 프로세스별 우선순위
   - **기한부** : 명시 시간 내에 수행
   - **FCFS** : 먼저 온 순서대로
   - **SJF** : 최소 시간 우선
   - **HRN**(Highest Response Ratio Next) : 응답률 순서
   
7. **IPv4**

   - 32bit 주소체계
   - 헤더크기 : 가변적
   - 전송방식 : 멀티캐스트, 유니캐스트, 브로드캐스트
   - 패킷 교환 방식의 네트워크 계층의 프로토콜

8. **IPv6**

   - 128bit 주소체계
   - 헤더크기 : 고정적
   - 전송방식 : 멀티캐스트, 유니캐스트, 애니캐스트

9. **디지털트윈(Digital Twin)**

   - 물리적인 사물과 컴퓨터에서 동일하게 표현되는 가상 모델
   - 실제 물리적인 자산대신 소프트웨어로 가상화함으로써 설계부터 제조, 서비스에 이르는 모든 과정의 효율성을 향상시킬수 있는 모델

10. **CPS(Cyber-Physical System)**

    - 가상 물리 시스템으로 인간의 개입없이 물리적인 요소와 SW기술을 활용하여 실시간으로 물리적 요소를 제어하는 컴퓨팅 요소가 결합된 복합 시스템

11. 재해복구 문제

    - **RTO**(Recovery Time Objective)
      //재해복구 시간 목표, 서비스를 복구하는데 걸리는 최대 허용 시간 

    - **RPO**(Recovery Point Objective)

      //재해복구 시점 목표, 유실을 감내할수 있는 데이터 허용 시점

12. **블록체인**

    - 분산 컴퓨팅 기술 기반의 데이터 위변조 방지 기술
    - P2P방식을 기반으로하여 소규모 데이터들이 연결되어 형성된 '블록'이라는 분산데이터 저장환경에 관리 대상 데이터를 저장함으로써 누구도 임의로 수정할 수 없고 누구나 변경의 결과를 열람할수 있게끔 만드는 기술.

13. 스케줄링 알고리즘

    - SRT(Shortest Remaing Time First)-선점형
      //가장 짧은 시간이 소요되는 프로세스를 수행, 남은 처리시간이 더 짧다고 생각하는 프로세스가 준비큐에 생성되면 언제라도 프로세스가 점유되는 스케줄링 알고리즘
    - SJF(Shortest Job First)-비선점형
      //프로세스가 도착하는 시점에 따라 그 당시 가장 작은 서비스 시간을 갖는 프로세스가 종료시까지 자원을 점유하는 스케줄링 알고리즘.

14. 유닉스/리눅스 명령어

    - **uname** : 시스템 정보확인, -a 옵션은 모든 정보 확인.
      ex) #username -a //모든 정보 확인
    - **cat** : 파일의 내용을 화면에 출력
      ex) #cat a.txt
    - **pwd** : 현재 작업중인 디렉터리의 절대경로
      ex) #pwd
    - **kill** : 특정 pid프로세스 종료
      ex) #kill -9 1111 //1111pid 프로세스 강제종료
    - **ifconfig** : 인터페이스 설정이나 확인
      ex) #ifconfig -a
    - **chmod** : 파일,디렉터리 권한 변경
      ex) #chmod 755 a.txt
    - **find** : 파일찾기
      ex) #find ./-name a.txt

# 12.제품스포트웨어패키징

1. 릴리즈 노트 작성 프로세스(**노정개영노추**)
   (1) **모**듈식별
   (2) 릴리즈 **정**보 확인
   (3) 릴리즈 **개**요 작성
   (4) **영**향도 체크
   (5) 릴리즈 **노**트 작성
   (6) **추**가 개선 항목 식별
2. **제품 소프트웨어 메뉴얼**
   - 제품 소프트웨어 개발단계부터 적용한 기준이나 패키징 이후 설치 및 사용자 측면의 주요 내용들을 기록한 문서
   - 사용자 중심의 기능 및 방법을 나타낸 설명서와 안내서를 의미
   - 설치메뉴얼과 사용자 메뉴얼이 있다.
3. 암호화 기술
   - **PKI**(공개키 기반 구조)
     //공개키 암호화 알고리즘을 사용하는 인프라
   - **RSA**
     //소인수분해의 어려움에 기반하는 공개키 암호화 알고리즘
4. 배포 프로세스(**빌패디패작정**)
   (1) **빌**드 내용 식별
   (2) **패**키징 도구 식별
   (3) **D**RM흐름을 확인하여 패키징
   (4) **패**키징 도구 설치
   (5) 배포 **작**업
   (6) **정**상 배포 확인
5. 패키징 도구
   - **코드 난독화**
     //저작권 보호를 위해 크랙 방지를 제공하는 도구중, 프로그램 소스코드를 알아보기 힘든 형태로 바꾸는 기술
6. DRM구성요소
   - 콘텐츠 제공자 : 콘텐츠를 제공하는 저작권자
   - 패키저 : 콘텐츠를 메타 데이터와 함께 배포 가능한 단위로 묶는 기능
   - DRM컨트롤러 : 배포된 컨텐츠의 이용권한 통제



# *서술형

1. **인스펙션** : 원시코드를 개발자가 아닌 **전문가**를 통해 오류를 찾아내는 **공식적 검토 방법**.(정적테스트)
2. **WSDL**(Web Service Description Language) : 웹서비스에 대한 **자세한 정보**를 **xml형식으로 기술한 언어**
3. **프로토타입** : 전체적인 **기능을 간단한 형태로 실제로 구현한 시제품**.
4. **DRM** : 디지털 컨텐츠에 대한 **권리정보를 지정**하고 암호화기술, 크랙방지 등의 기술을 사용하여 **허용된 범위안에서만 컨텐츠 이용이 가능하도록 통제**하는 기술.
5. **UDDI** : **WSDL을 등록하기 위한 저장소**로 **공개적으로 접근,검색이 가능**한 저장소.
6. **테스트 드라이버** : 상향식 통합 테스트에서 **데이터의 입출력을 확인**하기 위해서 하위모듈을 호출하는 **상위의 더미 모듈**
7. **SAN**(Storage Area Next) : 서버와 스토리지를 **광케이블 및 광채널 스위치**로 **근거리 네트워크 환경을 구성**하여 **빠른 속도로 데이터를 처리**할수 있는 **특수 목적용 고속 네트워크**
8. **IPSEC** : **IP계층**에서 **무결성과 인증을 보장하는 인증헤더(AH)**와 **기밀성을 보장하는 임호화(ESP)**를 이용하여, **EndPoint 구간**에서 **보안 서비스를 제공**하는 IP계층의 **보안 프로토콜**
9. **트랜잭션의 격리성** : 트랜잭션 실행중 **생성되는 연산의 결과**를 다른 트랜잭션이 **접근하지 못하도록 보장**하는 트랜잭션의 특징
10. **빅데이터** : 주어진 비용,시간안에 **처리가능한 데이터의 범위**를 넘어서는 **수십페타바이트(PB)크기의 데이터**
11. **AI** : 컴퓨터가 인간처럼 **지능적 행동과 사고를 모방**할수 있도록하는 **소프트웨어**
12. **AJAX** : **자바스크립트**를 사용하여 서버와 클라이언트 간에 **비동기적**으로 **XML데이터를 교환하고 조작하는 기술**
13. **스머프(Smurf)공격기법** : **네트워크 전체**에게 **ICMP echo파일을 직접 브로드캐스팅**하여 **마비**시키는 공격기법.



# *쿼리

1. 학생 테이블에 '이'씨 학생의 학번 출력 쿼리

   ```sql
   select 학번
   from 학생
   where 학생 LIKE '이%';
   ```

   - LIKE문
     - '이'가 들어가있는 사람 : WHERE 학생 LIKE '%이%';
     - '이'가 있고 뒤에 한글지만 있는 사람 : WHERE 학생 LIKE '이_';
     - '이'가 있고 뒤에 두글자만 있는 사람 : WHERE 학생 LIKE '이__';

2. 성적 테이블에서 IN키워드를 이용해서 '컴퓨터 구조'와 '알고리즘'과목에 대한 학번 별 평균 학점을 구하는 쿼리

   ```sql
   select 학번, avg(학점) as 평균
   from 성적
   where 과목 IN ('컴퓨터구조','알고리즘')
   group by 학번;
   ```

   - avg,sum,count와 같은 집계함수는 group by키워드를 사용해야 사용할수 있다.

3. 성적 테이블에서 '컴퓨터 구조'과목을 수강한 사람의 학번과 학점을 학점순(오름차순)으로 정렬하는 쿼리

   ```sql
   select 학번, 학점
   from 성적
   where 과목 = '컴퓨터 구조'
   order by 학점 ASC;
   ```

4. 성적 테이블에서 과목만 출력하는 쿼리(과목 중복x)

   ```sql
   select distinct 과목
   from 성적
   ```

5. 고객테이블에서 나이가 50이상, 59이하, 성별이 남자인 사람의 이름 출력(**BETWEEN사용**)

   ```sql
   select 이름
   from 고객
   where (나이 BETWEEN 50 AND 59) AND (성별='남자');
   ```

6. 학생 테이블에서 가장 높은 성적을 출력

   ```sql
   select 학번, 성적
   from 학생
   where 성적 = (select max(성적) 
              from 학생)
   ```

7. 학생 테이블에서 학생 테이블의 학번 속성을 이용하여 인덱스를 생성하고, 인덱스를 삭제하는 쿼리

   ```sql
   (생성)
   CREATE INDEX INDEX_STUDENT ON 학생(학번);
   
   (삭제)
   DROP INDEX INDEX_STUDENT ON 학생;
   ```

   - 생성 : CREATE INDEX 인덱스명 ON 테이블명(속성명1, 속성명2)
   - 삭제 : DROP INDEX 인덱스명 ON 테이블명; 