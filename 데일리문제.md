# 1.요구사항 확인

1. 소프트웨어 아키텍처 4+1뷰(**논구**는 **배프 유**)
   - **논**리뷰
   - **구**현뷰
   - **배**포뷰
   - **프**로세스뷰
   - **유**스케이스뷰
2. 요구사항 개발 프로세스(**도분명확**)
   (1) 요구사항 **도**출
   (2) 요구사항 **분**석
   (3) 요구사항 **명**세
   (4) 요구사항 **확**인
3. **프로토타이핑**
   // 사용자가 요구한 기능 등 소프트웨어의 전체 기능을 수행할수 있는 시제품을 만드는 과정
4. OSI 7계층
   - 7계층(응용 계층) - 데이터
   - 6계층(표현 계층) - 데이터
   - 5계층(세션 계층) - 데이터
   - 4계층(전송 계층) - 세그먼트
   - 3계층(네트워크 계층) - 패킷
   - 2계층(데이터링크 계층) - 프레임
   - 1계층(물리 계층) - 비트
5. tpmC
   - 특정 서버에서 자체 테스트를 수행하여 나온 결과중 **1분간 최대 처리건수**를 나타낸 수치
   - **가장 객관적으로 하드웨어 성능을 나타내는 수치**
6. 인터페이스
   - JDBC 
     //**자바**에서 DB를 사용하도록 연결해주는 응용 프로그램 인터페이스
   - ODBC
     //DB를 엑세스하기 위한 **표준 개방형** 응용프로그램 인터페이스
7. 요구사항 분석 기법(**분개할 협상**)
   - 요구사항 **분**류 : 기능인지 비기능인지
   - **개**념적 모델링 : 문제 도메인의 엔티티와 개별관계 및 종속성 반영
   - 요구사항 **할**당 : 아키텍처 구성 요소 식별
   - 요구사항 **협**상 : 이해관계자 합의
   - **정**형분석 : 요구사항 분석의 마지막 단계
8. 개념모델링
   - 문제 도메인의 엔티티와 개별관계 및 종속성 반영
   - 시나리오로 나타내기 위해 **유스케이스 다이어그램**을 주로 사용
   - 모델링 표기법은 **UML**
9. UML의 관계
   - **집합관계** : 하나의 사물이 다른 사물에 포함되어 있는것(독립적)
     //포함되는 쪽에서 포함하는 쪽(전체)로 빈 마름모
     //학생 <- 가방
   - **합성 관계** : 하나의 사물이 다른 사물에 필수적으로 포함되어있는것(의존적)
     //포함되는 쪽에서 포함하는 쪽(전체)으로 찬 마름모
     //자동차 <- 엔진
   - **실체화 관계** : 사물이 할수 있거나 해야하는 기능으로써 서로를 그룹화 할수 있는 관계(Can do this)를 표현
     //기능쪽으로 빈 점선 화살표 연결
11. UML
    - 시퀀스 다이어그램
      //동작에 참여하는 객체들이 주고 받는 메시지를 표현
    - 커뮤니케이션 다이어그램
      //동작에 참여하는 객체들이 주고 받는 메시지 표현 및 객체 간의 연관관계까지 표현하는 다이어그램
    - 상태 다이어 그램
      //하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호작용에 따라 상태가 어떻게 변하는지 표현하는 다이어그램.
12. UML스테레오 타입
    - << include >> : 하나의 유스케이스가 어떤 시점에 반드시 다른 유스케이스를 실행하는 포함관계
      // 의뢰하는 쪽 --> 실행하는 쪽
    - << extend >> : 하나의 유스케이스가 어떤 시점에 다른 유스케이스를 실행할수 있고, 그렇지 않을수도 있는 확장관계
      //의뢰하는 쪽 <-- 실행하는 쪽
    
12. 방법론

    - **애자일 방법론**
      //절차보다 사람을 중심으로 변화에 유연하고 신속하게 적응하여 효과적으로 시스템을 개발하는 방법론
      //XP, 린, 스크럼
    - **구조적 방법론**
      //분할과 정복 접근 방식의 방법론으로 프로세스 중심의 하향식 방법론
      //**나씨-슈나이더만** 차트 사용
    - **CBD**(component base development)
      //컴포넌트를 조합해서 새로운 응용 프로그램을 작성하는 방법론
    - **제품 계열 방법론**
      //특정제품에 적용하고 싶은 공통 기능을 정의하여 개발하는 방법론
      //임베디드 소프트웨어를 작성하는데 유용한 방법론
    - **UP방법론(Unified Process)**
      //소프트웨어 개발 단계를 **시간의 흐름에따라 4개의 범주(도입,상세,구축,이행)로 나누고**, **각 범주에는 요구사항 도출부터 설계, 구현, 평가까지의 개발 생명주기가 포함**되어 있는 방법론

13. 스크럼 관련 용어

    - **스크럼** : 매일 정해진 시간 장소에서 짧은 시간의 개발을 하는 팀을 위한 프로젝트 관리 중심 방법론
    - **백로그**
      //제품과 프로젝트에 대한 요구사항
    - **스프린트**
      //2~4주의 짧은 개발기간으로 반복적 수행으로 개발품질 향상
    - **스크럼 미팅**
      //15분정도의 미팅, To-Do List계획 수립
    - **스크럼 리더**
      //프로젝트 리더
    - **스프린트 회고**
      //스프린트 주기를 되돌아보며 개선점등을 확인 및 기록
    - **번다운 차트**
      //남아있는 백로그 대비 시간을 그래픽적으로 표현한 차트

14. 디자인 패턴

    - **Singleton 패턴**

      //생성
      //전역 변수를 사용하지 않고 **객체를 하나만 생성**해서 어디에서든지 참조할수 있도록 하는 디자인 패턴

    - **Observer 패턴**

      //행위
      //**일대 다의 의존성**을 가지며 상호작용하는 객체 사이에서 가능하면 느슨하게 결합하는 디자인 패턴

    - **Factory Method패턴**
      //생성
      //**상위 클래스에서 인터페이스를 정의**하고 **하위 클래스에서 인터페이스를 생성**하는 방식

    - **Facade 패턴**
      //하나의 인터페이스를 통해 느슨한 결합을 제공

    - **Builder 패턴**

      //생성
      //복잡한 인스턴스를 조립하여 만드는 구조
      //복합 객체를 생성할때 **객체를 생성하는 방법(과정), 객체를 구현(표현)하는 방법을 분리함**으로써 **동일한 생성 절차에서 서로 다른 표현 결과**를 만들 수 있는 패턴

    - **Memento 패턴**
      //클래스 설계 관점에서 **객체의 정보를 저장**할 필요가 있을때 적용하는패턴
      //**undo기능을 개발할때 사용**

    - **Decorator**
      //기존에 구현되어 있는 클래스에 **그때그때 필요한 기능을 추가**해 나가는 설계 패턴

    - **Prototype**
      //일반적인 원형을 만들어놓고, 그것을 복사한 후 필요한 부분만 수정하여 사용하는 패턴

    - **Adapter**
      //다른 곳에서 개발한 클래스를 우리에게 맞게 중간 변환 역할을 해줄수 있는 클래스 사용

    - **Composite**
      //**객체들의 관계를 트리구조**로 구성하여 **부분-전체 계층을 표현**
      //단일 객체와 복합 객체 모두 동일하게 다루도록 하는 구조 패턴

    - **Proxy**
      //시간이 많이 걸리는 작업을 할때, 대리인

    - **Command**
      //요청자체를 캡슐화하여 파라미터로 넘기는 패턴
      //동일한 명령을 반복해서 실행할때

    - **Visitor**
      //데이터와 메소드를 구분하기 위함

15. 디자인 패턴의 요소

    - 생성
      //FactoryMethod, Builder, Prototype, Singleton
    - 구조
      //Adapter, Bridge, Composite, Decorate, Proxy,Facade
    - 행위
      //Command, Memento, Observer, State, Visitor

16. ?

    - **시맨틱 웹**
      //리소스에 대한 정보와 자원 사이의 관계-의미 정보를 컴퓨터가 처리할 수 있는 형태로 표현하고 자동화된 컴퓨터가 처리하도록 하는 지능형 웹
    - **온톨로지**
      //실세계에 존재하는 모든 개념들과 속성, 개념간의 관계정보를 컴퓨터가 이해할수 있도록 서술해 놓은 개념화 명세서

17. 구조적 개발 방법론

    - 구조적 개발 방법론 : 정형화된 분석 절차에 따라 사용자 요구사항을 파악, 문서화하는 체계적 분석방법
      특징
      - 자료흐름도
      - 자료사전
      - 소단위 명세서 : 데이터 흐름도에 나타나 있는 처리 항목을 1~2페이지 정도의 소규모 분량으로 요약, 논리적 명세

18. 개발 보안 방법론

    - **CLASP(Comprehensive, LightWeight Application Security Process)**
      //역할 기반 프로세스로 구성된 집합체, **이미 운영중인 시스템에 적용하기 적당**한 소프트웨어 개발 보안 방법론
    - **Seven Touchpoints**
      //7가지 보안 강화 활동을 정의한 소프트웨어 개발 보안 방법론
      //SW보안의 모범사례

19. Linked Open Data

    - 전세계 오픈된 정보를 하나로 묶는 방식
    - Linked data 와 Open data의 합성어
    - URI를 사용
    - RESTful방식으로 볼수있다
    - 링크 기능이 강조된 시맨틱 웹에 속하는 기술

20. XP(eXtreme Programming)

    - 모호한 요구사항이 변화하는 요구사항에 직면한 중규모의 소프트웨어 개발팀을 위한 가벼운 개발론
    
    - 핵심가치(**의단용피존**)
      - 의사소통
      - 단순성
      - 용기
      - 피드백
      - 존중
    - 기본원리(**짝테전리소계**)
      - 짝 프로그래밍(Pair Programming)
      - 테스트 주도 개발(Test-Driven Development)
      - 전체 팀(While Team)
      - 리팩토링(Refactoring)
      - 소규모릴리즈(Small Releases)
      - 계속적인 통합(Continuous Integration)
    - **메타포어**
      - 공통적인 이름 체계와 시스템 서술서를 통해 고객과 개발자간의 의사소통을 원할하게 한다는 원리

# 2.데이터입출력구현

1. **이상현상**

   //데이터의 중복성으로 인해 릴레이션을 조작할때 발생하는 비합리적인 현상

2. **프로시저**
   //SQL을 이용하여 생성된 데이터를 조작하는 프로그램

3. 데이터 조작 프로시저(**프함패트**)

   - 저장된 **프**로시저 : 복잡한 트랜잭션을 수행하는 PL/SQL문을 DB에 저장하는 기능 제공 프로그램
   - 저장된 **함**수 : 실행결과를 되돌려 받을수 있는 프로그램
   - 저장된 **패**키지 : 프로시저나 함수를 효과적으로 관리하기 위해 패키지 단위로 배포할때 사용하는 프로그램
   - **트**리거 : 특정 테이블에 삽입,수정,삭제 등의 변경 이벤트 발생시 DBMS에서 자동으로 실행되도록 구현된 프로그램.
   
4. 데이터베이스 설계(**요개논물구**)

   - **요**구사항 분석 : 정보 내용 및 요구수집, 경영목표 및 제약조건 식별, 요구명세서 작성 및 검토
   - **개**념적 설계 : DBMS독립적 개념스키마 설계, 트랜잭션 모델링, view통합방법 고려, Attribute합성
   - **논**리적 설계 : 목표DBMS에 맞는 스키마 설계, 트랜잭션I/F설계, 스키마 평가 및 정제
   - **물**리적 설계 : 목표 DBMS에 맞는 물리적 구조 설계, 트랜잭션 세부설계, 저장 레코드 양식 설계, 레코드 집중 분석 및 설계
   - **구**현 : 데이터베이스 생성, 트랜잭션 생성
   
5. 트랜잭션 특징

   - 원자성(atomicity) : DB에 변경사항이 모두 적용되는가 되지않는가
   - 일관성(durability) : 트랜잭션의 작업 처리 결과는 항상 일관성 있어야한다.
   - 지속성(consistency) : 트랜잭션이 성공적으로 완료 되었으면 영구적으로 지속되야한다.
   - 독립성(isolation) : 트랜잭션이 연산을 수행중일떄 다른 트랜잭션이 끼어들수없다.

# 3.통합구현

1. 데이터 모델
   
   - 실제 세계의 정보를 컴퓨터에 저장하기 위해 단순화하여 개념적 모형
   
   - 구성요소
     - 객체
     - 속성
     - 관계
   - 표시할 구성요소
     - 구조
     - 연산
     - 제약조건
   
2. EAI구축 환경

   - EAI(Enterprise Application Integration)-연계솔루션(간접 연계 방식 기술)
     //기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션 간의 정보 전달, 연계 등을 가능하게 해주는 솔루션
   - **Point-to-Point**
     - 중간에 미들웨어 없이 각 애플리케이션간 연결
     - 특징
       - 솔루션 구매 없이 통합
       - 변경, 재사용 어려움
       - 상대적으로 저렴
   - **Hub & Spoke**
     - 허브 시스템을 통해 데이터를 전송하는 중앙 집중형 방식
     - 특징
       - 모든 데이터 전송 보장
       - 허브 장애 시 전체 영향
       - 확장, 유지보수 용이
   - **Message Bus(EBS)**
     - 애플리케이션 사이 미들웨어(버스)를 두어 처리
     - 특징
       - 뛰어난 확장성, 대용량 처리 가능
   - **Hybride**
     - 그룹 내에는 Hub&Spoke방식, 그룹 간에는 Messsage Bus방식
     - 특징
       - 표준 통합 기술
       - 데이터 병목 현상 최소화

3. 연계메커니즘
   - 직접연계
     - DB링크
     - DB연결
     - OpenAPI
     - JDBC
     - 하이퍼링크
   - 간접연계
     - 연계솔루션(EAI)
     - Web Server
     - 소켓

4. 상향식 통합 테스트의 절차 나열
   (1) **모듈 또는 컴포넌트가 하위 모듈 기능을 수행하는 클러스터로 통합**
   (2) **드라이버라는 제어프로그램 작성**
   (3) **각 통합된 클러스터 단위 테스트**
   (4) **각 클러스터들은 프로그램의 위쪽으로 결합, 드라이버는 실제 모듈 또는 컴포넌트로 대체**.

5. 요구사항 도출 기법
   - 체크리스트 : 기준에 대한 **점검**을 통한 분석기법
   - 브레인스토밍 : 자발적으로 **자연스럽게** 제시된 **아이디어 목록**을 통해 분석하는 기법
   - 델파이 : **전문가 경험**
   - 인터뷰 : 사용자 면담
   - 설문지 : 설문지 분석

6. XrML

   - 디지털 콘텐츠/웹 서비스 권리 조건을 표현한 XML기반의 언어

7. 정규화

   - 테이블 속성들이 상호 종속관계를 갖는 특성을 이용해 무손실 분해를 하는 과정
   - 순서
     - 도메인은 원자값
     - 부분 함수적 종속 제거
     - 이행적 함수적 종속 제거
     - 결정자는 후보키
     - 다치 종속 제거
     - 조인 종속
   - 반정규화
     - 종류
       - 테이블 통합
       - 중복 테이블 추가
       - 중복 속성 추가
       - 테이블 분할

# 4.서버프로그램구현

1. 응집도
   - **우**연적 응집도 : 뚜력한 관계x
   - **논**리적 응집도 : 논리적으로 유사한 기능
   - **시**간적 응집도 : 특정시간
   - **절**차적 응집도 : 순서대로 수행
   - **통**신적 응집도 : 동일한 입출력 자료, 다른 기능
   - **순**차적 응집도 : 한 요소의 출력자료가 다른 요소의 입력자료
   - **기**능적 응집도 : 모듈 내 모든 요소들이 단일 기능 수행
2. 결합도
   - **내**용 결합도 : 한 모듈이 다른 모듈의 내부 기능 및 자료를 직접 참조
   - **공**통 결합도 : 공통 데이터 영역을 다른 모듈이 함꼐 사용
   - **외**부 결합도 : 한 모듈에서 선언한 데이터를 외부 모듈에서 참조
   - **제**어 결합도 : 다른 모듈 내부의 논리적 흐름을 제어하기 위해 제어 신호를 사용하여 통신하거나 제어 요소 전달
   - **스**탬프 결합도 : 모듈 간의 인터페이스로 배열이나 레코드 등의 자료구조가 전달
   - **자**료 결합도 : 다른 모듈을 호출하면 매개변수나 인수로 데이터를 넘겨주고 처리 결과를 돌려주는 방식
3. 프레임워크의 특징(**모확재제**)
   - **모**듈화 : 인터페이스에 의한 캡슐화를 통해 모듈 강화, 변경에 대한 영향 극소화
   - **확**장성 : 다형성을 통해 인터페이스를 넓게 사용가능
   - **재**사용성 : 반복적으로 사용될수 있는 컴포넌트의 정의로 재사용성 높아짐, 개발자의 생산성 높아짐
   - **제**어의 역흐름 : 제어가 프레임워크로부터 애플리케이션으로 반대로 흐르게 된다.
4. 공통모듈 명세기법(**정명완일추**)
   - 정확성 : 시스템 구현시 이 기능이 필요하다는 것을 알도록 정확히 작성
   - 명확성 : 해당 기능을 중립적으로 생각하지 않도록 기능에 대해 명확히 작성
   - 완전성 : 시스템 구현을 위한 모든 기능 기술
   - 일관성 : 공통 기능들간 상호충돌이 발생하지 않도록 작성
   - 추적성 : 기능에 대한 요구사항 출처, 관련시스템 등의 관계를 파악할수 있어야한다.
5. 모듈화 측정 척도
   - **fan-in** : 참조하는 모듈 갯수(들어오는 화살표 갯수)
   - **fan-out** : 참조되는 모듈 갯수(나가는 화살표 갯수)
6. Quartz Cron 표현식
   - 초,분,시,날짜,월,요일,년
   - 옵션
     - *:모든시간
     - ? : 어떤 값이든 상관없다
     - -범위
     - /:0/15면 15초마다 트리거

# 5.인터페이스구현

1. 인터페이스 구현 도구
   - **xUnit** : 다양한 언어지원
     //Java(JUnit),C++(CppUnit),.Net(NUnit)등 다양한 언어를 지원하는 단위 테스트 프레임워크
     //SW의 함수나 클래스 같은 서로 다른 구성 원소를 테스트 할 수 있게 해주는 테스트 도크
   - **STAF** : 다양한 환경지원 및 재사용 및 확장성
     //서비스호출, 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크
   - **Fitnesse** : 웹 기반 테스트 케이스 설계 등 지원 및 협업 기능
   - **NTAF** : Fitnesse의 장점인 협업 기능과 STAF의 장점인 재사용 및 확장성을 통합한 NHN(NAVER)의 테스트 자동화 프레임워크
   - **Selenium** : 다양한 브라우저 지원 및 개발언어를 지원하는 웹 애플리케이션 테스트 프레임워크, 테스트 스크립트 언어를 학습할 필요없이 기능 테스트를 만들기 위한 도구 제공
   - **watir** : 루비 기반
   - **SCOUTER** : 애플리케이션에 대한 모니터링 및 DB Agent를 통해 오픈소스 DB모니터링 기능, 인터페이스 감시기능을 제공하는 도구.
2. 인터페이스 연계 시 적용할 수 있는 보안 프로토콜
   - **SSL/TLS**
     //전송계층과 응용계층 사이에서 클라이언트와 서버간의 웹 데이터 암호화(기밀성),전송시 데이터 무결성을 보장하는 보안 프로토콜
   - **S-HTTP(Secure Hypertext Transfer Protocol)**
     //웹 상에서 네트워크 트래픽을 암호화하는 주요 방법 중 하나
     //클라이언트와 서버간에 전송되는 Http를 사용하는 애플리케이션에 한해서 모든 메시지를 암호화하여 전송하는 보안 프로토콜 
   - S-HTTP와 HTTPS차이
     //암호화 방식의 차이
     //S-HTTP는 SSL을 사용하지 않고 HTTP와 같은 포트를 사용하면서 message단위로 암호화
3. 인터페이스 관련 도구
   - **APM(Application Performance Management)**
     //인터페이스 작동이 잘 되고 있는지 감시하는 도구
     //커넥션 풀등의 자원 관리 도구
4. **VPN(Virtual Private Network)**
   - 터널링 기법을 사용해서 인터넷과 같은 공중망에서 전용 회선을 구성한 것과 같은 효과를 내는 가상 네트워크
5. **SPICE**
   - 소프트웨어 프로세스를 평가 및 개선하는 국제 표준

# 6.화면설계

1. UI설계 기본 원칙(**직유학유**)
   - **직**관성 : 누구나 쉽게 이해하고, 쉽게 사용할수 있어야 한다.
   - **유**효성 : 정확하고 완벽하게 사용자의 목표가 달성될수 있도록 제작.
   - **학**습성 : 초보와 숙련자 모두가 쉽게 배우고 사용할수 있도록 제작.
   - **유**연성 : 사용자의 인터렉션을 최대한 포용하고, 실수를 방지할 수 있도록 제작.
2. **스토리보드**
   - 구축하는 서비스에 대한 대부분의 정보가 수록된 문서
   - 디자이너와 개발자가 최종적으로 참고하는 산출 문서
3. UI품질 요구사항(**기신사 효유이**)
   - **기**능성(Funtionality)
   - **신**뢰성(Reliability)
   - **사**용성(Usability)(**사이학운**)
     - **이**해성 : SW의 논리적인 개념과 적용가능성을 분간.
     - **학**습성 : 애플리케이션을 익히는데 필요한 사용자의 노력 정도.
     - **운**용성 : SW활용과 운용통제에 필요한 사용자의 노력 정도.
   - **효**율성(Efficiency)
   - **유**지 보수성(Maintainability)
   - **이**식성(Portability)
4. 웹의 3요소(**표접호**)
   - 웹 **표**준
   - 웹 **접**근성
   - 웹 **호**환성
5. WCAG 2.0의 원칙(웹접근성)(웹 접근에 **이견인**는 사람은 **운**다)
   - **이**해성 : 가독성, 예측가능성, 입력 지원의 세부지침이 있다.
   - **견**고성 : 호환성의 세부지침
   - **인**식의 용이성 : 대체 테스트, 실시간 미디어 대체수단, 융통성, 식별성이 세부지침에 있다.
   - **운**용의 용이성 : 키보드 접근성, 충분한 시간 제공 및 시간조절 기능, 발작 예방, 탐색 가능성의 세부지침이 있다.
6. UI시나리오 문서 작성의 요건(**완일이가 추수**)
   - **완**전성
     //시스템보다 사용자의 태스크에 초점을 맞춰야한다
     //UI시나리오는 누락이 없어야하고 최대한 빠짐없이 상세하게 기술
   - **일**관성
     //서비스에 대한 목표, 시스템 및 사용자의 요구사항이 일관성 있어야 한다.
   - **이**해성
     //처음 접하는 사용자도 이해하기 쉽도록 구성하고 설명해야한다.
   - **가**독성
     //문서를 쉽게 읽을수 있어야 하고 표준화된 템플릿을 작성하여 적용한다.
   - **추**적 용이성
     //변경사항들이 언제,어디서,왜 발생하였는지 추적이 쉬워야 한다.
   - **수**정 용이성
     //시나리오에 반영함에 있어 쉽게 적용할수 있어야한다.

# 7.애플리케이션 테스트 관리

1. 통합테스트
   - **드라이버** : 상향식 통합 테스트에서 사용하는 더미모듈로 상위모듈에서 데이터의 입력과 출력을 하기 위한 더미 모듈
   - **스텁** : 하향식 통합 테스트에서 사용하는 더미모듈로 하위 컴포넌트를 대신하는 더미모듈.
   - **빅뱅테스트** : 모든 모듈을 한번에 통합후 테스트, 종료시점에 한번 테스트
   - **혼합식 통합 테스트(샌드위치 테스트)** : 테스트 하위 수준에서는 상향식 통합테스트, 테스트 상위 수준에서는 하향식 통합테스트.
   
2. **단위 테스트**
   - 사용자 요구사항에 대한 단위 모듈, 서브루틴 등을 테스트하는 단계
   - 종류(**인자실오**)
     - **인**터페이스 테스트
     - **자**료구조 테스트
     - **실**행 경로 테스트
     - **오**류 처리 테스트
   
3. 테스트 레벨(**단통시인**)
   - **단**위 테스트
   - **통**합 테스트
   - **시**스템 테스트
   - **인**수 테스트
   
4. 결함 우선순위
   - 결정적
   - 높음
   - 보통
   - 낮음
   
5. 결함 조치 상태
   - **열린** : 오류가 발견되었지만 분석되지 않은 상태
   - **할당된** : 오류가 개발자에게 할당된 상태
   - **연기된** : 우선순위가 낮아 잠시 미뤄진 상태
   - **종료된** : 수정되고 더 이상의 오류가 발생되지 않는 상태
   - **수정된** : 개발자에 의해 오류가 수정된 상태
   - **분류된** : 오류 등록은 되었지만 분석결과 오류가 아님으로 결정난 상태
   
6. 목적에 따른 테스트 종류(**회**와 **안성**탕면의 조합을 **강구**하기 위해서 **회**를 **병**째 먹었다)
   - **회**복 테스트 : 결함을 주고 얼마나 빠르게 회복하는지
   - **안**전 테스트 : 불법적인 침입으로부터 시스템을 보호할수 있는지
   - **성**능 테스트 : 응답 시간, 처리량 테스트
   - **강**도 테스트 : 과도한 정보량을 부과하여 과부화에도 정상적인 실행을 하는지
   - **구**조 테스트 : 논리적인 경로, 코드 복잡도 테스트
   - **회**귀 테스트 : 수정된 코드에서 새로운 결함이 없음을 확인
   - **병**행 테스트 : 기존sw와 수정된sw에 동일한 입력값을 주고 비교
   
7. 커버리지 테스트
   - **구문** 커버리지 : 전체 구문 실행
   - **조건** 커버리지 : 내부 조건 True,False한번 씩 실행
   - **결정** 커버리지 : 전체 결과 True,False한번 씩 실행
   - **조건/결정** 커버리지 : 내부조건과 전체 결과가 True,False한번씩
   
8. 애플리케이션 테스트 관리
   - 화이트박스 테스트와 블랙박스 테스트의 수행순서는 **결함 검출률과 관계없다**
   - 리그레이션(회귀)테스트는 반복성향 때문에 **자동화 테스트에 적합**
   - 디버깅은 **개발활동**
   - 타 시스템과 연동 테스트는 **통합 테스트 단계**
   
9. 애플리케이션 성능 개선 방안(**아품애 호소**)
   - **아**키텍처 조정 : FactoryMethod 패턴
   - 소스코드 **품**질 분석 도구 : StringBuffer,StringBuffer클래스, Log4j
   - **애**플리케이션 성능 현황 관리 : 성능 현황판(Q-Board) 작성
   - 프로그램 **호**출 순서 조정 : 호출하는 함수 먼저 코딩
   - **소**스 코드 최적화 기법 적용 : 개발 프레임워크의 코딩 표준, 인터페이스를 통해 추상화된 자료구조를 구현하여 의존성 최소화.
   
10. 소스코드 최적화 기법(**클린코드 작성원칙**)(**가단의 중추**)
    - **가**독성 : 이해하기 쉬운 용어 사용
    - **단**순성 : 한번에 한가지의 기능만 처리
    - **의**존성 : 코드의 변경이 다른 코드에 영향이 가지 않도록.
    - **중**복성 : 중복 코드 제거
    - **추**상화 : 동일한 수준의 추상화 구현, 상세 내용은 하위 클래스에서 구현
    
11. 소프트웨어 테스트의 원리
    - **완벽한 테스트는 불가능**
    - **개발 초기에 테스팅 시작**
    - **결함집중** : 80%의 결함은 20%에 집중되어있다.
    - **살충제 페러독스** : 똑같은 테스트케이스를 반복하면 새로운 결함을 찾을수 없다.
    - **테스팅은 정황에 의존적** : 소프트웨어 성격에 맞게 테스트 실시
    - **오류-부재의 궤변** : 요구사항이 충족되지 못하면, 결함이 없어도 품질이 좋지못하다.
    
12. 테스트 관련

    - 인스펙션 : 저작자 외 전문가가 문제를 식별하는 공식적 검토 방법
    - 워크스루 : 검토회의전 요구사항 명세서를 미리 배포하여 짦은 검토회의
    - 조건 커버리지 : 개별 조건식이 적어도 한번은 참과 거짓
    - 상태전이 : 이벤트에 의해 어느 한 상태에서 다른 상태로 전이되는 경우의 수를 수행하는 테스트

13. **스파게티 코드**

    - 컴퓨터 프로그램의 소스 코드가 복잡하게 얽힌 모습을 비유한 표현
    - 작동은 정상적으로 하지만,  사람이 코드를 읽으면서 그 코드의 작동을 파악하기는 어려운 코드

14. 애플리케이션 테스트의 법칙

    - **브룩스의 법칙**

      //인력으로 인해 개발 생산성이 향상되지 않고 오히려 방해된다는 법칙

    - **파레토 법칙**
      //전체 결과의 80%가 전체 원인의 20%에서 일어나는 현상, 결함집중의 원리를 내포하고 있는 법칙

    - Jackson법칙

    - Boehm법칙
      //나선형 모형 제안

15. 경곗값 분석의 테스트 케이스

    ```
    1. 휴대폰 연쳬
    1~5일
    6~10일
    11~20일
    21~30일
    
    2. 경계설정 : 1일,6일, 11일, 21일, 30일
    
    3.유효값, 무효값 모두 고려
    ```

    - 위 문제는 value를 정해주지 않았음으로 3value문제
    - 위 문제는 유효값 무효값을 모두 고려하는 3value(경계값, 경계값의 위,아래 값)를 구해야하므로
      => 0,1,2,5,6,7,10,11,12,20,21,22,29,30,31 일
    - 3value이 아닌 2value(경계값과 위,아래 값중 비교)이다
      특히 1~30까지가 유효값 범위이므로
      => 0,1,5,6,10,11,20,21,30,31 일
      //0과 31이 무효값이므로 꼭 포함시켜줘야함

# 8.SQL응용

1. DESCRIBE

   - 테이블 또는 뷰 구조를 조회할때 사용하는 명령어

2. VIEW

   - 물리적인 테이블을 기반으로 생성되며, 데이터 딕셔너리에 SELECT구문 형태로 저장되는 객체

3. Rollback과 SavePoint

   - Rollback
     //트랜잭션이 실패했을때 작업을 취소하고 이전 상태로 되돌리는 데이터 제어어
   - SavePoint
     //트랜잭션 실행도중 특정 지점으로 상태를 되돌리는 데이터 제어어

4. INSERT

   ```
   INSERT INTO 테이블명(속성)
   VALUES(입력값);
   ```

5. INDEX

   ```
   CREATE INDEX 인덱스명
   ON 테이블명(속성값);
   ```

6. VIEW

   ```
   CREATE VIEW 뷰명
   AS SELECT문;
   ```

7. PL/SQL

   - 표준 SQL을 기본으로 Oracle에서 개발한 데이터 조작 언어
   - 모든 프로시저 작성에 사용

8. 회복기법

   - **UNDO** 
     - 로그를 이용하여 모든 변경을 취소시키는 방법
     - 트랜잭션의 **원자성**
   - **REDO**
     - 최근의 복제본을 적재시킨후 복제본 이후에 일어난 변경만을 로그를 이용하여 재실행
     - 트랜잭션의 **영속성**
   - **지연갱신 회복 기법**
     - 모든 변경내용을 로그파일에만 저장하고 데이터베이스에 커밋이 발생할때까지 저장을 지연하는 기법
     - UNDO가 필요없고 원자성을 보장할수 없다
   - **즉시갱신 회복 기법**
     - 변경 정보를 로그 파일에 저장하고 모든 변경 내용을 즉시 데이터베이스에 반영하는 기법
     - 회복 시 파일을 참조하여 REDO와 UNDO연산을 모두 실행
   - **CheckPoint 회복기법**
     - CheckPoint이후만 즉시 갱신 또는 지연갱신
   - **그림자 페이징 회복기법**
     - 트랜잭션이 실행되는 동안 현재 페이지 테이블과 그림자 페이지 테이블 2개의 페이지 테이블을 유지하고 관리하는 회복 기법
   - **미디어 회복기법**
     - 데이터베이스 전체 내용을 안전한 저장소에 복사

9. **장애 투명성**
   // 장애가 발생해도 데이터 무결성이 보장

10. **관계대수**

    - 원하는 정보를 검색하기 위해 어떻게 유도하는가를 기술하는 절차적 언어
    - 연산자
      - 순수 관계 연산자
        - SELECT : 릴레이션제 존재하는 튜플 중 특정 조건을 만족하는 튜플들의 부분집합을 구하여 새로운 릴레이션을 만든다.
        - PROJECT : 주어진 릴레이션에서 속성 리스트에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만든다.
        - JOIN : 공통 속성을 중심으로 두개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산
        - DIVISION : 한 릴레이션의 모든 튜플에 연관되어있는 다른 릴레이션의 튜플을 선택
      - 일반 관계 연산자
        - 합집합
        - 교집합 등..

11. **관계해석**

    - 원하는 정보를 정의하는 비절차적인 언어

# 9.소프트웨어 개발 보안 구축

1. 보안약점(**입보시에코캡아**)
   - **입**력데이터 검증 및 표현 : SQL삽입, 크로스 사이트 스크립트(XSS)
   - **보**안기능 : 인증,권한 관리, 암호화
   - **시**간 및 상태 : Race Condition, 무한루프
   - **에**러 처리 : 오류메시지로 정보노출, try-catch
   - **코**딩 오류 : 널 포인터 역참조, 자원 해제, 초기화
   - **캡**슐화 : 잘못된 세선에 의한 노출, 제거되지 않은 디버깅 코드
   - **A**PI오용 : 안전하지 않은 함수, DNS에 의존적
   
2. SW개발 보안3대 요소(**기무가**)
   - **기**밀성 : 시스템 내의 자원과 정보는 인가된 사용자만 사용가능.
   - **무**결성 : 인가된 사용자에 의해서만 수정이 가능하다.
   - **가**용성 : 인가받은 사용자는 언제든지 사용할 수 있다.
   
3. **스턱스넷(Stuxnet)**
   - 2010년에 발견된 웜 바이러스
   - **지멘스의 SCADA시스템**을 감염
   - **PLC**를 감염시켜 장비동작 변경
   
4. **다크데이터(DarkData)**
   
   - 정보를 수집후, 저장만 하고 분석에 활용하고 있지 않는 다량의 데이터
   - 방치되고 있는 데이터는 저장 공간만 차지하고 위험을 초래할수 있다.
   
5. **킬 스위치(kill switch)**
   
   - 잃어버린 스마트폰을 주은 사람이 해당 폰을 이동통신망 또는 와이파이에 접속하면 폰 주인이 원격으로 분실 기기를 사용불능하도록 만듦
   - 워너크라이 랜섬웨어가 퍼질때 워너크라이 내의 도메인을 정식으로 등록하면서 랜섬웨어를 만았을떄 킬스위치라고 불림.
   
6. **APT(Advanced Persistent Threat)**
   
   - 특수 목적을 가진 조직이 하나의 표적에 대해 IT기술을 이용해 지속적으로 정보 수집
   - 취약점을 파악해 침투,검색,수집,유출하는 기법
   
7. 재해 관련 보안
   - **BCP(Business continuity Planning)**
     //기업이 재난이나 재해로 타격을 입은 뒤 업무를 어떻게 복구할것인지에 대한 계획.
     //전산 복구 뿐만 아니라 고객 비즈니스의 **지속성**을 보장한다.
     
   - **DRS**
     //재해나 재난시 서비스 연속성을 보장하기 위해 메인 센터와 분리되어 동일한 역할을 하는 재해 복구 센터

     유형

     - **Hot Site**
       - Active-Standby 구성
       - RTO : 수시간
     - **Mirror Site**
       - 전체 데이터 복제
       - RTO : 0
     - **Warn Site**
       - 주요 업무만 보관
       - RTO : 수 일
     - **Cold Site**
       - 재해 시 시스템 신규설치
       - RTO : 수 주. 개월

   - **RTO(Recovery Time Objective)**
     //재해 복구 목표 시간
     //중요한 서비스일 수록 시간이 짧아야함.
     
   - **RPO(Recovery Point Objective)**
     //데이터의 손실허용시점
     
   - **BIA(Business Impacte Analysis)**
     //BCP를 구축하기 위한 비즈니스 영향 분석

8. **크라임 웨어(CrimeWare)**
   
   - 온라인 상에서 **불법활동을 조장**하기 위해 만들어진 프로그램
   - 공격용 툴킷이라고 불림
   - 인터넷에서 곧바로 사용할수 있으며 **키로거를 은밀히 설치 시켜 불법적으로 정보 수집**
   
9. 보안 공격 기법
   - **Smurf** : 브로드 캐스트하여 타겟 마비
   - **RUDY** : 바디부분을 소량으로 보내 자원을 고갈
   - **티어드롭** : IP Fragment offset을 중첩하여 수신자가 재조합하는 과정에서 오류.
   
10. 소프트웨어 개발 보안
    - **SSO**(Single Sign On)
      //인증 시스템의 하나, 한번의 인증을 통해서 여러 개의 서비스를 이용할수 있는 시스템.
    
11. IPSEC의 세부 프로토콜
    - **IKE**(Internet Key Exchange)
      //보안 관련 설정들을 생성, 협상 및 관리하는 프로토콜로 udp500번 포트를 사용하는 프로토콜
    - **AH**(Authentication Header)
      //기밀성(암호화)을 제외한 메시지 인증코드(MAC)를 이용한 인증(무결성),송신처 인증을 제공해주는 프로토콜
    - **ESP**(Encapsulating Security Payload)
      //메시지 인증코드(MAC)와 암호화를 이용하여 인증(무결성),송신처 인증, 기밀성을 제공하는 프로토콜
    
12. **버퍼오버플로우(buffer overflow)**
    
    - 버퍼오버플로우
      //정해진 메모리의 범위를 넘치게해 원래 리턴 주소를 변경시켜 임의 프로그램이나 함수를 실행시키는 시스템 해킹 기법
    - 버퍼오버플로우 대응방안
      - 운영체제의 주기적인 최신 패치 적용
      - 입력값 검증이 가능한 안전한 함수 사용(**strncpy()**)
      - **스택가드(StackGuard)**
        //카나리(carnary)라고 불리는 무결성 체크용 값을 복귀 주소와 변수 사이에 삽입해 두고 버퍼 오버플로우시 카나리의 값이 변하게 된다면 복귀주소를 호출하지 않는 방법.
      - **스택쉴드(StackShield)**
        //함수 시작시 복귀주소를 Global RET이라는 특수 스택에 저장해 두고 함수 종료시 저장된 값과 RET스택의 값을 비교하여 다를 경우 오버플로우로 간주하고 프로그램 종료
      - **ASLR(Address Space Layout Randomization)**
        //메모리의 공격을 벙어하기 위해 주소 공간 배치를 난수화하고, 실행 마다 메모리 주소를 변경시켜 버퍼 플로우를 통한 특정 주소 호출을 차단하는 방법.
    - 버퍼오버플로우 공격 유형
      - **스택 버퍼 오버플로우(stack buffer overflow)**
        //Local Value나 Return Address가 저장되는 스택 영역에서 발생하는 공격
      - **힙 버퍼 오버플로우(heap buffer overflow**
        //프로그램 실행시 동적으로 할당되는 힙 영역에서 할당된 버퍼 크기를 초과하는 데이터를 입력하여 공격자가 원하는 임의의 코드를 공격
    
13. SW개발 보안 용어
    - **자산**(Assert) : 조직의 데이터 또는 소유자가 **가치를 부여한 대상**
    - **위협**(Threat) : 조직이나 기업의 **자산**에 **악영향을 기칠수 있는 사건이나 행위**
    - **위험**(Risk) : 취약점을 이용하여 **자산의 손실 또는 피해를 가져올 가능성**.
    
14. 보안공격 기법
    //입력데이터 검증 및 표현(보안약점)의 공격기법
    - **XSS**(Cross Site Scripting)
      //검증되지 않는 데이터가 포함된 웹페이지가 전송되는 경우, 사용자가 해당 웹페이지를 열람함으로써 웹페이제 포함된 부적절한 스크립트가 실행되는 공격기법
    - **SQL**삽입
      //악의적인 SQL을 삽입,실행시켜 DB의 접근을 통해 정보를 탈취하거나 조작등의 행위를 하는 공격기법.
    - **CSRF**(Cross Site Request Forgery)
      //사용자가 자신의 의지와 다르게 공격자가 의도한 행위(수정,삭제,등록)를 웹사이트에 요청하게 하는 공격 기법.
    - **TFN**(Tribe Flood Network)
      //여러 개의 목표 시스템에 대해 서비스 거부 공격을 수행할 수 있는 도구
      //간편하게 DDos공격을 시도할수있게한다
    
15. 비밀키 암호화 알고리즘
    - **AES**(Advanced Encryption Standard)
      
      //NIST
      //고급암호화 표준이라고 불리는 암호화 알고리즘
      //블록크기는 128비트, 키 길이에 따라 128,192,256비트로 분류할수 있다
      //암호화 복호화 과정에서 동일한 키를 사용하는 대칭 키 알고리즘
      
    - **SEED**
      //KISA,ETRI에서 개발하고 TTA에서 인증한 안전성,신뢰성이 우수한 고속 블록단위의 128비트 대칭키 암호화 알고리즘
      
    - **DES**(Data Encryption Standard)
      //NBS
      //56bit의 키를 사용
      //64bit의 평문 블록을 64bit의 암호문 블록으로 만드는 블록 방식의 암호화 알고리즘
      
    - **SHA(Secure Hash Algorithm)-256**
      //256비트의 해시값 생성
      //단방향성 성질을 띄고 있는 암호화 방법으로 복호화 불가능
    
16. 보안 공격관련 용어

    - **사회공학** : 컴퓨터 보안에 있어서, 인간 상호 작용의 깊은 신뢰를 바탕으로 사람들을 속여서 정상 보안 절차를 꺠트리기 위한 비기술적 시스템 침입 수단.
    - **감성공학** : 인간의 감성을 측정 및 평가하고 과학적으로 분석하여 구체적인 제품 설계로 실행해내는 공학
    - **그레이웨어** : 바이러스나 명백한 악성 코드를 포함하지 않는 합법적 프로그램이면서 사용자를 귀찮게 하거나 위험한 상황에 빠뜨릴수 있는 프로그램.

17. 네트워크 공격 기법

    - **TCP 세션 하이재킹**
      //TCP의 세션 관리 취약점을 이용한 공격기법
      //공격자가 대상의 패킷을 가로채 Sequence Number를 획득하여 비동기화 상태로 패킷이 유실된 대상은 재전송 패킷 증가
      //ACK Storm증가 NW부하 증가
      - 대응방법
        - 비동기화 상태 탐지
        - ACK패킷 비율 모니터링
        - 특정 세션에서 패킷 유실 및 재전송 증가 탐지

18. **허니팟**

    - 정보 시스템의 침입자를 속이는 기법
    - 가상의 정보시스템을 만들어 놓고 실제 공격을 당하는 것처럼 보이게 하여 침입자를 추적하는 역할

19. **IP Spoofing**

    - 공격자가 IP주소를 변경하여 우회하여 공격하는것.

20. 서버 접근 통제

    - 서버 접근 통제 과정
      **식별 / 인증/ 권한부여**

    - 서버 접근 통제 유형
      - 임의적 접근통제(DAC)
        //자원에 대한 접근을 사용자계정에 기반
      - **MAC(Mandatory Access Control, 강제적 접근 통제)**
        //사용자가 갖는 접근 허가 권한에 근거하여 객체에 대한 접근을 제한하는 방법
      - 역할기반 접근통제(RBAC)
        //자원에 대한 접근은 사용자에게 할당된 역할에 기반한다.
    - 접근 통제 보호모델
      - 벨-라파둘라 모델 : 기밀성을 강조하는 통제모델
      - 비바 모델 : 무결성을 보장하는 최초모델

21. **웹 방화벽(WAF,Web Application Firewall)**

    - 웹 애플리케이션 보안에 특화된 보안 장비
    - SQL삽입, XSS와 같은 웹 공격을 탐지하고 차단하는 장비

22. **DLP(Data Loss Prevention)**

    - 내부 정보 유출 방지
    - 기업에서 정보를 보호하고 외부 유출을 방지하기 위해 사용하는 보안 기술

23. **코드 인스펙션**

    - 정적 테스트의 가장 일반적인 유형
    - 사전에 정의된 코드 작성 규칙기반으로 소스코드 점검

24. **하드코딩**

    - 계정관리부분에서 아이디 또는 패스워드가 스크립트상에 직접 작성되지 않도록 조심해야하는데, 소스 코드나 빌드 스크립트 상에 아이디나 패스워드를 **직접 작성**하는것.

25. **리팩토링(Refactoring)**

    - 유지보수 생선성 향상을 목적으로 기능을 변경하지않고 **내부적으로 구조,관계 등을 단순화**하여 소프트웨어의 유지보수성을 향상시키는 기법

26. **테일러링(Tailaring)**

    - **표준 프로세스를 커스터마이징**하여 프로젝트의 비즈니스적으로 또는 기술적인 요구에 맞게 **적합한 프로세스를 얻는 과정**

27. **tripwire**

    - 크래커가 백도어를 만들거나 설정 파일을 변경했을때 분석하는 도구

28. **루트킷**

    - 불법적인 해킹에 사용되는 악의적인 기능들을 제공하는 도구

29. **PICONET**

    - UWB기술 또는 블루투스 기술로 통신망 형성

30. **MashUp**

    - 웹에서 제공하는 정보 및 서비스를 이용해 새로운 소프트웨어나 서비스 등을 만드는 기술

31. **Mesh Network**

    - 기존 무선 랜의 한계를 극복하기 위해 특수목적을 위한 새로운 방식의 네트워크 기술

32. **Secure OS**

    - 커널에 보안 기능을 추가한것

33. **스니핑**

    - 공격대상을 직접공격하지않고 데이터만 몰래 들여다보는 수동적 공격기법

34. 대칭키 암호화 알고리즘(반대/=> 공개키 암호화 알고리즘)

    - **블록 암호 방식** : 긴 평문을 암호화 하기 위해 고정 길이의 블록을 암호화
    - **스트림 암호 방식** : 매우 긴 주기의 난수열을 발생시켜 평문과 더하여 암호문 생성
    - **디피-헬만** : 암호 키를 교환하는 방식, 두 사람이 공통의 비밀키 공유

35. **포렌식**

    - 범죄 사실의 전자적 증거물에 대해서 수집,분석,보고서를 작성하는 일련의 과정

36. **IPS**(Intrusion Prevent System)

    - 네트워크에 대한 공격이나 침입을 차단하고 유해트래픽을 차단해주는 솔루션

# 10.프로그래밍 언어 활용

1. 프로그래밍 언어(**절차적 프로그래밍 언어**)

   - 알골(ALGOL) : 알고리즘 연구 개발 목적 언어(**알고리즘 -> 알골**)
   - 리스프(LISP) : 수학 표기법을 나타내기위한 목적 언어(**수학->리스프**)
   - 프롤로그(Prolog) : 논리식 기반으로 객체간의 문제 해결(**논리->Pro-logical**)
   - 하스겔(Haskell) : 함수형 프로그래밍언어, 코드간결, 에러 적음(**함수->ㅎㅅ->하스겔**)
   - C : 이식성이 좋아 컴퓨터 기종에 상관없이 프로그램을 작성할 수 있음
   - 코볼(COBOL) : 사무처리용언어, 영어 문장 형식으로 구성되어 있어 이해와 사용이 쉬움, 4개의 DIVISION으로 구성되어 있음
   - FORTRAN : 과학 기술 계산용 언어, 수학과 공학 분야의 공식이나 수식과 같은 형태로 프로그래밍 할 수 있음

2. 프로그래밍 언어(**객체 지향 프로그래밍 언어**)

   - Java : 분산 네트워크 환경에 적용가능, 멀티스레드 기능을 제공하여 여러 작업을 동시에 할수 있다.
   - C++ : C언어에 객체지향 개념을 적용한 언어, 모든 문제를 객체로 모델링하여 표현함
   - Smalltalk : 1세대 객체지향 프로그래밍 언어 중 하나로 순수한 객체지향 프로그래밍 언어, 최초로 GUI제공

3. C++ switch문

   ```c++
   switch 문에서 break 가 없다면 연속으로 case 문이 출력된다.
   std::cout<<"수";는 줄 바꿈없고 띄어쓰기 없다.
   std::cout<<"수"<<std::endl; 은 줄 바꿈.
   ```

4. **자료구조**

   - 컴퓨터에 데이터를 삽입,삭제,수정 할수 있게 해주는 **논리적인 공간구조**
   - 자료의 형태에 따라 단순구조, 선형구조, 비선형 구조, 파일 구조로 분류

5. 사용자 정의 자료형

   - **구조체(Structure)** : 사용자가 기본타입을 가지고 새롭게 정의할 수 있는 사용자 정의 자료형.
   - **열거형(Enumeration)** : 서로 연관된 정수형 상수들의 집합, 상수에 이름을 붙혀 코드 이해도움.
   - **공용체(Union)** : 모든 멤버 변수가 하나의 메모리 공간을 공유하는 사용자 정의 자료형.

6. 객체 지향 프로그래밍

   - 객체 지향 프로그래밍 구성요소
     - 객체 : 개체,속성과 메소드로 이루어진  클래스의 인스턴스
       - 개체 : 현실 세계에 보이는 본질
       - 속성 : 객체가 가지고 있는 정보
       - 메소드 : 객체가 메시지를 받아서 실행해야할 연산
     - 클래스 : 하나 이상의 객체로 묶은 하나의 공통된 특징
     - 메시지 : 객체간의 관계
   - 객체 지향 프로그래밍 특징
     - 캡슐화 : 내부에 필요한 속성과 메소드를 외부로부터 보호
     - 추상화 : 개체 속성들 중 특징적인 것을 모델화
     - 상속 : 이미 정의된 상위 클래스의 메소드를 하위 클래스가 물려받음
     - 다형성 : 객체는 다양한 모양을 가지고 있음을 의미

7. 파이썬 타입

   ```python
   a={'일본','중국','한국'}
   a.add('베트남') //베트남추가
   a.add('중국')	//중국은 중복값이므로 무시
   a.remove('일본')	//일본제거
   a.update({'홍콩','한국','태국'})	//기존값에 있다면 무시, 없으면 추가, 홍콩,태국 추가
   print(a)	//{'중국','한국','베트남','홍콩','태국'}
   ```

   - 파이썬의 타입

     | 자료형     | 설명                                                         | 문법 예시                                                    |
     | ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
     | 리스트형   | 리스트 안에서는 어떠한 자료형도 포함시킬 수 있습니다.        | 리스트명=[요소1,요소2]<br />ex) test=[1,2,'한국']            |
     | 튜플형     | 리스트는 그 값의 생성, 삭제, 수정이 가능하지만 튜플은 그 값을 바꿀수 없는 특성을 제외하고는 리스트형과 비슷 | 튜플명=(요소1,요소2)<br />ex) test=(1,2,'한국')              |
     | 세트형     | 집합에 관련된 것을 처리하기 위해 만든 자료형                 | 세트명 = set([요소1,요소2,...])<br />세트명={요소1,요소2,...}<br />ex) a={'일본','중국','한국'} |
     | 딕셔너리형 | 대응 관계를 나타내는 자료형                                  | 딕셔너리명={키1:값1,키2:값2}<br />ex) test={1:"가",2:"나"}   |

8. c++ 생성자, 소멸자

   ```c++
   ﻿#include <iostream>
   using namespace std;
   class A{
   public:
     A( ){
       cout << "A" << endl;
     };
     A(int a){
       cout << "B" << endl;
     };
     ~A( ){
       cout << "C" << endl;
     };
     void fn( ){
       cout << "D" << endl;
     }
   };
   
   void main( ){
     A a = A(5);
     a.fn( );
   }
   ```

   - main메소드에서 A클래스의 파라미터 5를 가지고 있는 생성자를 호출(생성자) => B
   - a.fin()호출 => D
   - main메소드가 종료(소멸자) => C

9. 포인터 생성자

   ```c++
   #include <iostream>
   using namespace std;
   class A{
   public:
     A( ){
       cout << "A" << endl;
     };
     A(int a){
       cout << "B" << endl;
     };
     ~A( ){
       cout << "C" << endl;
     };
     void fn( ){
       cout << "D" << endl;
     }
   };
   
   void main( ){
     A *a = new A(5);
     a->fn();
   }
   ```

   - A *a 라고하면 A 클래스를 저장하고 있는 공간을 가리키는 a라는 이름의 포인터 변수를 만듬
   - 포인터 변수(a)에 new로 메모리를 할당해주었으면 delete로 메모리를 해제해야한다, 하지만 이 코드에서는 delete를 따로 해주지 않았기떄문에 프로그램을 종료해도 메모리는 할당되있는 상태(메모리 누수)
   - delete a를 선언해주어야 메모리 누수가 적용되지않는다.
   - A *a = new A(5);로 생성자를 만들었을때 함수를 불러올떄 a->fn();
   - 정답 : B, D

10. 파이썬 생성자, 소멸자

   ```python
   class A:
     def __init__(self):
       print("생성자")
     def __del__(self):
       print("소멸자")
   
   a = A()
   del a
   ```

11. 파이썬 연산자

    ```python
    print(2**3) //2^3
    print(3**2) //3^2
    ```

12. c출력

    ```c
    "%.2f" //소수점자리 둘째자리까지 출력
    ```

13. 생성자

    - 객체 초기화 함수
    - 객체를 생성할때 반드시 호출되고 제일먼저 실행되는 함수

14. ```
    char p = "KOREA",
    printf("%s\n",p); //KOREA
    printf("%s\n",p+3);	//EA
    printf("%c\n",*p);	//K
    printf("%c\n",*(p+3));	//E
    printf("%s\n",*p+2);	//M
    ```

    - p는 값
    - *p는 주소값

# 11.응용SW기초 기술 활용

1. **계층형 데이터베이스**

   - 데이터를 상하 종속 관계로 계층화 하여 관리하는 데이터베이스
   - 데이터에 대한 접근은 빠르지만, 변화하는 데이터 구조에 유연하게 대응하기 쉽지않다.

2. 라우팅 프로토콜(**BORI=보리**)

   - **R**IP : 최초 라우팅 프로토콜, 라우팅 루프 발생가능(거리벡터 알고리즘)
   - **I**GRP : RIP업그레이드(거리벡터 알고리즘)
   - **B**GP : 가장 규모가 큰 네트워크
   - **O**SPF : 링크 상태 알고리즘(링크상태 알고리즘)

3. **게이트웨이(GateWay)**
   //전송계층
   //프로토콜은 다른 통신장치에 접속할 수 있게 해주는 장치
   //데이터를 보내거나 받는 출입구 역할

4. 네트워크 전송기술

   - **유니 캐스트** : 1대1 데이터 전송
   - **애니 캐스트** : 단일 송신자 -> 가장 가까운 노드
   - **멀티 캐스트** : 일대다, 특정 그룹에게만 데이터 전송가능
   - **브로드 캐스트** : 단일 송신자 -> 모든 수신자

5. 데이터베이스 기초 활용

   - **차수(degree)** : 하나의 릴레이션에서 **속성**의 개수
   - **카디너리티(cardinality)** : 하나의 릴레이션에서 **튜플**의 개수

6. 프로세스 스케줄링 알고리즘

   (1)**선점형** : 현재 실행중인 프로세스가 있을때 다른 프로세스의 우선순위가 높을때 현재 실행중인 프로세스를 중지

   - **라운드로빈(Round Robin)** : 시간 할당량, 시간안에 완료못하면 뒤로 보냄
   - **SRT(Shortest Remaining Time First)** : 가장 짧은 처리 우선 수행
   - **다단계 피드백 큐** : RR + FCFS, 우선순위 단계

   (2)**비선점형** : 현재 실행중인 프로세스가 있을때 다른 프로세스는 CPU점유 불가능

   - **우선순위** : 프로세스별 우선순위
   - **기한부** : 명시 시간 내에 수행
   - **FCFS** : 먼저 온 순서대로
   - **SJF** : 최소 시간 우선
   - **HRN**(Highest Response Ratio Next) : 응답률 순서, (대기시간+서비스시간)/서비스시간
   
7. **IPv4**

   - 32bit 주소체계
   - 헤더크기 : 가변적
   - 전송방식 : 멀티캐스트, 유니캐스트, 브로드캐스트
   - 패킷 교환 방식의 네트워크 계층의 프로토콜

8. **IPv6**

   - 128bit 주소체계
   - 헤더크기 : 고정적
   - 전송방식 : 멀티캐스트, 유니캐스트, 애니캐스트

9. **디지털트윈(Digital Twin)**

   - 물리적인 사물과 컴퓨터에서 동일하게 표현되는 가상 모델
   - 실제 물리적인 자산대신 소프트웨어로 가상화함으로써 설계부터 제조, 서비스에 이르는 모든 과정의 효율성을 향상시킬수 있는 모델

10. **CPS(Cyber-Physical System)**

    - 가상 물리 시스템으로 인간의 개입없이 물리적인 요소와 SW기술을 활용하여 실시간으로 물리적 요소를 제어하는 컴퓨팅 요소가 결합된 복합 시스템

11. 재해복구 문제

    - **RTO**(Recovery Time Objective)
      //재해복구 시간 목표, 서비스를 복구하는데 걸리는 최대 허용 시간 

    - **RPO**(Recovery Point Objective)

      //재해복구 시점 목표, 유실을 감내할수 있는 데이터 허용 시점
      
    - **DRS**
      //재해시 연속성을 유지하기 위해 메인보드와 분리되어 같은 기능을 하는 재해 복구 시스템

      - 유형(핫미 웜콜)
        - Hot Site
        - Mirror Site
        - Warm Site
        - Cold Site

12. **블록체인**

    - 분산 컴퓨팅 기술 기반의 데이터 위변조 방지 기술
    - P2P방식을 기반으로하여 소규모 데이터들이 연결되어 형성된 '블록'이라는 분산데이터 저장환경에 관리 대상 데이터를 저장함으로써 누구도 임의로 수정할 수 없고 누구나 변경의 결과를 열람할수 있게끔 만드는 기술.

13. 스케줄링 알고리즘

    - SRT(Shortest Remaing Time First)-선점형
      //가장 짧은 시간이 소요되는 프로세스를 수행, 남은 처리시간이 더 짧다고 생각하는 프로세스가 준비큐에 생성되면 언제라도 프로세스가 점유되는 스케줄링 알고리즘
    - SJF(Shortest Job First)-비선점형
      //프로세스가 도착하는 시점에 따라 그 당시 가장 작은 서비스 시간을 갖는 프로세스가 종료시까지 자원을 점유하는 스케줄링 알고리즘.

14. 유닉스/리눅스 명령어

    - **uname** : 시스템 정보확인, -a 옵션은 모든 정보 확인, -r 배포버전
      ex) #username -a //모든 정보 확인
    - **cat** : 파일의 내용을 화면에 출력
      ex) #cat a.txt
    - **pwd** : 현재 작업중인 디렉터리의 절대경로
      ex) #pwd
    - **kill** : 특정 pid프로세스 종료
      ex) #kill -9 1111 //1111pid 프로세스 강제종료
    - **ifconfig** : 인터페이스 설정이나 확인
      ex) #ifconfig -a
    - **chmod** : 파일,디렉터리 권한 변경
      ex) #chmod 755 a.txt
    - **find** : 파일찾기
      ex) #find ./-name a.txt
    - **grep** : 특정 문자열 찾기
    
15. IPv4->IPv6 방법

    - **듀얼스택**
    - **터널링**
    - **주소변환**

16. 공유 매체에 대한 다중 접근 방식

    - **CSMA/CD**

      //충돌탐지
      //유선랜에서 채널이 사용중인지 체크하고 사용중이지않을때 전송

    - **CSMA/CA**
      //충돌회피
      //무선랜에서 사전에 충돌 탐지 가능성이 있으면 널널할때 보내는 방식

17. QOS

    - **QOS** : 전송 계층이 요구하는 서비스 품질

18. IPv4 클래스

    - A클래스
    - B클래스
      //A시작값 + 128
    - C클래스
      //B시작값 +64
    - D클래스 : 멀티캐스트 용도로 예약된 주소
      //C시작값 + 32
    - E클래스 : 연구를 위해 예약된 주소
      //D시작값 + 16

19. 리눅스 운영체제에서 권한 부여

    - 사용자에게 읽기,쓰기,실행 권한 부여
    - 그룹에게 읽기,실행 권한 부여
    - 그외 실행 권한 부여
    - 한 줄의 명령어로 작성, 아라비안 숫자를 사용하여 8진수 권한으로 부여

    -> r:4, w:2, x:1 이므로 chmod rwx rx x a.txt -> **chmod 751 a.txt**

20. **MariaDB**

    - 리눅스 환경에서 사용하는 MySQL를 기반으로 제작한 GPL(General Public License)오픈 소스 데이터베이스

21. **MyBatis**

    - XML서술자나 어노테이션을 사용하여 저장 프로시저나 SQL문으로 객체를 연결시키는 프로그램

22. **Tomcat**

    - 웹 서버에서 서블릿,JSP,빈즈와 같은 자바 코드를 이해하기 위해서는 Tomcat같은 자바를 이해하는 엔진이 필요함
    - Apach Software Foundation에서 서버인 자바를 움직이게 하기 위해서 개발한 WAS의 일종

23. **HA(High Availability)**

    - 서버와 네트워크, 프로그램 등의 정보시스템이 시스템의 **장애에 대응하여 상당히 오랜 기간 동안 지속적으로 정상 운영이 가능한 성질**

24. **LDAP(LightWeight Directory Access Protocol)**

    - 사용자 정보를 유지하기 위한 질의 및 디렉터리 서비스의 등록, 수정, 삭제 및 검색을 위한 목적으로 개발한 인터넷 프로토콜

25. **ETL(Extraction, Transformation, Loading)**

    - 원천시스템으로 부터 데이터를 **추출**하고 작업을 거쳐 목적 시스템으로 **전송** 및 **로딩**하는 데이터 이동 프로세스

26. **CDC(Change Data Capture)**

    - 데이터베이스 시스템의 변경된 데이터를 캡쳐하여 다양한 운영 및 분석시스템으로 실시간 전달하는 기술
    - "실시간 작업환경 구축","운영시스템 부하 감소","신뢰성 있는 데이터 복제"특징

27. **네트워크 슬라이싱**

    - 하나의 물리적인 네트워크 인프라를 서비스 형태에 따라 **다수의 독립적인 가상 네트워크로 분리**하여 서로 다른 특성을 갖는 **다양한 서비스들에 대한 특화된 전용 네트워크를 제공**

28. **NLP(Natural Language Processing, 자연어 처리)**

    - 컴퓨터와 사람의 언어 사이의 상호작용에 대해 연구하는 컴퓨터 과학과 어학의 한 분야

29. **쿠버네티스**

    - 파일럿을 뜻하는 그리스어
    - **컨테이너화된 애플리케이션**의 자동 배포, 스케일링 등을 제공하는 오픈소스 기반의 관리시스템

30. **맵 리듀스**

    - 구글에서 대용량 데이터 처리를 **분산 병렬 컴퓨팅에서 처리**하기 위한 목적으로 제작
    - **아파치 하둡으로 대표되는 소프트웨어 프레임워크**

31. **하둡**

    - 분산 환경에서 빅데이터를 저장하고 처리

32. **Devops(데브옵스)**

    - Development와 Operations의 합성어
    - 소프트웨어 개발자와 정보기술 전문가 간의 소통,협업 및 통합을 감조하는 개발 환경이나 문화를 말하는 용어

33. **블록체인**

    - 분산 데이터베이스의 한 형태
    - 분산 노드의 운영자에 의한 임의조작이 불가능 하도록 고안
    - 분산 컴퓨팅 기술 기반의 데이터 위변조 방지 기술
    - **PoW(Proof of Work)** 
      //확률적으로 해답이 어려운 문제를 빨리 해결한 사람에게 블록 생성을 허가하는 합의 알고리즘
    - **PoS(Proof of Stake)**
      //화폐량을 더 많이 소유한 사람에게 블록 생성을 허가하는 합의 알고리즘
    - **Baas**
      //블록체인 개발환경을 클라우드로 서비스 하는 개념
    - **스마트 계약(Smart Contract)**
      //해당 조건 달성 시 제 3자의 개입없이 특정 계약 조건을 자동적으로 실행하기 위한 기술

34. **NAT(Network Address Transformation)**

    - 네트워크 주소 변환

35. **순차코드**

    - 코드 설계에서 일정한 일련번호를 부여하는 방식의 코드

36. 미들웨어 솔루션

    - **TP monitor**
      트랜잭션이 올바르게 처리되고 있는지 데이터를 감시하고 제어하는 미들웨어
    - **MOM**
      메시지 기반의 비동기형 메시지 전달 방식 미들웨어
    - **Legacyware**
      기존 애플리케이션이나 DB기반에 새로운 업데이트된 기능을 덧붙이고자 할떄 사용되는 미들웨어
    - **ORB**
      코바 표준스펙을 구현한 객체 지향 미들웨어
    - **RPC**
      응용 프로그램의 프로시저를 사용해서 원격 프로시저를 로컬 프로시저처럼 호출하는 방식의 미들웨어
    - **EAI**
      서로 다른 플랫폼 및 애플리케이션들 간 정보전달, 통합을 가능하게 해주는 솔루션

37. **럼바우(Rumbaugh)객체지향 분석 절차**

    1. 개념 모형
    2. 동적 모형
       - 상태 다이어그램
    3. 기능 모형

38. **집단화**

    - 객체지향 기법에서 클래스들 사이의 '부분-전체','부분'의 관계로 설명되는 연관성을 나타내는 용어

39. **자료흐름도 구성요소**

    - process
    - data flow
    - data store
    - terminator

40. 객체지향 설계 원칙(SOLDI)

    - **LSP**(Liskov Substitution Principle, 리스코프 치환원칙)
      //자식 클래스는 언제나 자신의 부모클래스를 대체할수 있다
    - **ISP**(Interface Segregation Principle,인터페이스 분리 원칙)
      //한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야한다.
    - **DIP**(Dependency Inversion Principle, 의존 역전 원칙)
      //의존 관계를 맺을 때 변화하기 쉬운것보다 변화하기 어려운것에 의존하라
    - **SRP**(Single Responsibility Rinciple, 단일 책임 원칙)
      //모든 클래스는 각 하나의 책임만 가져야 한다.
    - **Open Closed Principle**(개방-폐쇄 원칙)
      //기존의 코드는 변경하지 않으면서 기능을 추가할수 있도록 설계가 되어야한다.

41. 클라우드 컴퓨팅 유형

    - **IaaS(Infrastructure as a Service)**
      //서버, 스토리지 같은 시스템 자원을 클라우드로 제공하는 서비스
      //EC2

    - **PaaS(Platform as a Service)**
      //애플리케이션을 개발,실행,관리 할 수 있게 하는 플랫폼을 제공하는 서비스
      //구름, GoogleApp Engine, AWS Lamda

    - **SaaS(Software as a Service)**

      //설치할 필요없이 클라우드를 통해 제공되는 SW
      //구글 클라우드, 네이버 클라우드, 웹메일

42. 교착상태

    - **교착상태 조건**(상점 비환)
      - 상호 배제 : 한번의 한개의 프로세스만이 공유 자원을 사용할수 있어야한다.
      - 점유와 대기 : 하나의 자원을 점유하고 있는 프로세스가 다른 프로세스가 점유하고 있는 자원을 얻기위해 대기
      - 비선점 : 다른 프로세스가 가지고 있는 자원은 사용이 끝나기전에 사용할수없다.
      - 환형 대기 : 공유 자원을 사용하기 위해 대기하는 프로세스가 원형으로 구성되어있다.
    - **교착상태 해결**(예회발회)
      - 예방 기법 : 교착 상태가 발생하지 않도록 사전에 시스템을 제어하는 방법
      - 회피 기법 : 교착상태가 발생하면 피하는 방법(은행원 알고리즘)
      - 발견 기법 : 교착 상태에 있는 프로세스와 자원을 발견
      - 회복 기법 : 교착상태를 만든 프로세스 종료, 교착상태의 프로세스에 할당된 자원을 선점

43. 메모리 분산 할당

    - 페이징 기법 : 프로세스를 일정 크기의 페이지로 잘라서 메모리 할당
      - 문제 
        - 내부 단편화(적재후 남는 메모리 공간)
        - **스레싱** : 프로세스에 지속적인 페이지 부재가 발생하여 프로세스의 실제 처리보다 페이지 교체 시간이 더많아지는 현상
      - 해결
        - **워킹 셋** : 프로세스가 많이 참조하는 페이지의 집합을 주기억 장치 공간에 계속 상주하게 해서 페이지 교체 현상을 줄이고자 하는 기법
        - **페이지 부재 빈도(PFF)** : 페이지 부재율을 예측하고 조절하는 기법
    - 세그먼트 기법 : 프로세스를 크기가 다른 블록 단위인 세그먼트로 분할하여 메모리에 할당 : 외부 단편화(할당된 크기가 프로세스보다 작아서 사용하지 못하는 공간)
    - **페이지 결함**
      - 주 기억장치에 페이지를 넣을때 해당 페이지가 존재하지 않다면 결함발생

44. **RAID**(Redundent Array Independent Disk, 복수 배열 독립 디스크)
    여러개의 디스크 배열로 이루어진 데이터 블록을 다른 디스크에 분산 저장하는 기술

45. **TCO**

    - 소프트웨어 개발할때 드는 총 소비비용

46. **SDDC**(Software Define Data Center)

    - 모든 하드웨어가 가상화되어 가상자원 풀을 구성하고 소프트웨어가 필요한 기능 및 규모에 따라 동적 자원을 할당, 관리하는 역할을 수행하는 데이터 센터

47. **NAS**(Network Attached Storaged)

    - 서버와 저장 장치를 네트워크로 연결하는 방식
    - 별도의 운영체제를 가진 서버 한 곳에서 파일을 관리허ㅏ기 때문에 서버 간 스토리지 및 파일 공유가 용이한 스토리지 장치 구성 방식

# 12.제품스포트웨어패키징

1. 릴리즈 노트 작성 프로세스(**모정노 영정 추**)
   (1) **모**듈식별
   (2) 릴리즈 **정**보 확인
   (3) 릴리즈 **노**트개요 작성
   (4) **영**향도 체크
   (5) **정**식 릴리즈 노트 작성
   (6) **추**가 개선 항목 식별
2. 릴리즈 노트 작성 항목(**헤개목 재수사면**)
   - 헤더 : 릴리즈 노트 이름, 버전 등의 기존 정보
   - 개요 : 간략한 내용
   - 목적 : 릴리즈 버전을 진행한 이유
   - 재현 항목 : 버그를 발견하게된 상황설명
   - 수정 / 개선 항목 : 수정 개선한 내용 설명
   - 사용자 영향력 : 패치후 사용자에게 끼치는 영향
   - 면책 조항 : 프리웨어 및 불법복제 방지
3. **제품 소프트웨어 메뉴얼**
   - 제품 소프트웨어 개발단계부터 적용한 기준이나 패키징 이후 설치 및 사용자 측면의 주요 내용들을 기록한 문서
   - 사용자 중심의 기능 및 방법을 나타낸 설명서와 안내서를 의미
   - 설치메뉴얼과 사용자 메뉴얼이 있다.
4. 암호화 기술
   - **PKI**(공개키 기반 구조)
     //공개키 암호화 알고리즘을 사용하는 인프라
   - **RSA**
     //소인수분해의 어려움에 기반하는 공개키 암호화 알고리즘
5. 배포 프로세스(**빌패디패작정**)
   (1) **빌**드 내용 식별
   (2) **패**키징 도구 식별
   (3) **D**RM흐름을 확인하여 패키징
   (4) **패**키징 도구 설치
   (5) 배포 **작**업
   (6) **정**상 배포 확인
6. 패키징 도구
   - **코드 난독화**
     //저작권 보호를 위해 크랙 방지를 제공하는 도구중, 프로그램 소스코드를 알아보기 힘든 형태로 바꾸는 기술
7. DRM구성요소
   - 콘텐츠 제공자 : 콘텐츠를 제공하는 저작권자
   - 패키저 : 콘텐츠를 메타 데이터와 함께 배포 가능한 단위로 묶는 기능
   - DRM컨트롤러 : 배포된 컨텐츠의 이용권한 통제
8. 사용자 매뉴얼 작성 항목
   - 문서 이력 정보
     //버전,작성자,작성일,검수인 등을 일자별로 기록
9. DRM 기술요소(**암키암식 저정크인**)
   - 암호화
     - 대칭키(암호화, 해독을 동일한 키 사용)
     - 비대칭키(서로 다른키로 암복호화)
     - 전자서명
     - PKI(공개키 암호화방식)
   - 키 관리
   - 암호 파일 생성
   - 식별 기술
     - DOI : 디지털 저작물에 특정한 번호 부여, 바코드 시스템
     - URI : 인터넷에 있는 자원을 나타내는 유일한 주소
   - 저작권 표현
     - XrML : 디지털 콘텐츠/웹서비스 권리 조건을 표현한 XML기반의 마크업 언어
     - MPEG-21 : 멀티미디어 관련 요소들이 통일된 상호 운용성을 보장하는 멀티미디어 표준 규격
   - 정책 관리
     - XML : 웹브라우저에서 HTML이 상호 호환되지 않는 문제와 SGML의 복잡함을 해결하기 위한 마크다운 언어
     - CMS : 각종 컨텐츠를 컨텐츠 생산부터 폐기까지 전 공급 관정을 관리하는 기술
   - 크랙 방지
     - 코드 난독화
     - Secure DB : 커널 암호화 방식으로 데이터베이스 파일을 직접 암호화하는 DB보안 강화 기술
   - 인증
     - SSO : 한번의 인증으로 여러 정보시스템에 인증절차없이 접근할수 있는 통합로그인 기술



# *서술형

1. **인스펙션** : 원시코드를 개발자가 아닌 **전문가**를 통해 오류를 찾아내는 **공식적 검토 방법**.(정적테스트)
2. **WSDL**(Web Service Description Language) : 웹서비스에 대한 **자세한 정보**를 **xml형식으로 기술한 언어**
3. **프로토타입** : 전체적인 **기능을 간단한 형태로 실제로 구현한 시제품**.
4. **DRM** : 디지털 컨텐츠에 대한 **권리정보를 지정**하고 암호화기술, 크랙방지 등의 기술을 사용하여 **허용된 범위안에서만 컨텐츠 이용이 가능하도록 통제**하는 기술.
5. **UDDI** : **WSDL을 등록하기 위한 저장소**로 **공개적으로 접근,검색이 가능**한 저장소.
6. **테스트 드라이버** : 상향식 통합 테스트에서 
7. **데이터의 입출력을 확인**하기 위해서 하위모듈을 호출하는 **상위의 더미 모듈**
8. **SAN**(Storage Area Next) : 서버와 스토리지를 **광케이블 및 광채널 스위치**로 **근거리 네트워크 환경을 구성**하여 **빠른 속도로 데이터를 처리**할수 있는 **특수 목적용 고속 네트워크**
9. **IPSEC** : **IP계층**에서 **무결성과 인증을 보장하는 인증헤더(AH)**와 **기밀성을 보장하는 임호화(ESP)**를 이용하여, **EndPoint 구간**에서 **보안 서비스를 제공**하는 IP계층의 **보안 프로토콜**
10. **트랜잭션의 격리성** : 트랜잭션 실행중 **생성되는 연산의 결과**를 다른 트랜잭션이 **접근하지 못하도록 보장**하는 트랜잭션의 특징
11. **빅데이터** : 주어진 비용,시간안에 **처리가능한 데이터의 범위**를 넘어서는 **수십페타바이트(PB)크기의 데이터**
12. **AI** : 컴퓨터가 인간처럼 **지능적 행동과 사고를 모방**할수 있도록하는 **소프트웨어**
13. **AJAX** : **자바스크립트**를 사용하여 서버와 클라이언트 간에 **비동기적**으로 **XML데이터를 교환하고 조작하는 기술**
14. **스머프(Smurf)공격기법** : **네트워크 전체**에게 **ICMP echo파일을 직접 브로드캐스팅**하여 **마비**시키는 공격기법.
15. **Rollback** : 트랜잭션이 실패한 작업이 취소될경우 이전 상태로 되돌리는 데이터 제어어 
16. 데이터 모델
    - **개념적 데이터 모델** : 실제 세계의 인식을 추상적 개념으로 표현하는 과정
    - **논리적 데이터 모델** : 개념적 데이터 모델에서 얻은 개념적 구조를 컴퓨터 환경에 맞게 변경하는 과정
    - **물리적 데이터 모델** : 데이터가 저장되는 방법 정의, 물리 데이터베이스의 설계 과정
17. **테스트케이스** : 요구사항을 완벽히 만족하는지 확인하기 위한 테스트 항목에 대한 명세서
18. **테스트 시나리오** : 테스트 케이스의 집합으로 테스트 케이스의 동작 순서를 기술한 문서
19. **프로토콜** : 서로 다른 기기들간의 데이터 교환을 원활하게 수행할수 있도록 표준화 시켜놓은 통신규약
20. **스키마** : 데이터베이스의 구조와 제약조건에 대한 명세를 작성한것.
    - **개념 스키마** : 데이터베이스의 전체적인 논리적 구조
    - **내부 스키마** : 데이터베이스의 물리적 저장구조 정의
    - **외부 스키마** : 실제 데이터들을 어떤 형식,구조, 배치화면을 통해 사용자에게 보여줄것인가 정의
21. **미들웨어** : 운영체제와 응용 소프트웨어 중간에서 조정과 중개 역할을 수행하는 소프트웨어
22. **트랜잭션** : 데이터베이스의 상태를 변경시켜주기 위해 수행하는 작업의 단위
23. **트리거** : 테이블에 대한 이벤트에 반응하여 관련 작업이 자동으로 실행되는 작업
24. **인터페이스** : 서로 관련없는 것들을 연결해주기 위한 시스템
25. **프로세스** : 운영체제가 관리하는 실행단위
26. **스레드** : 프로세스의 실행단위
27. **프레임워크** : 설계와 구현을 재사용이 가능하게끔 클래스를 제공하는 툴
28. **UML** : 객체 지향 소프트웨어 개발과정에서 이해관계자 간의 의사소통이 원활하게 이루어지도록 표준화한 객체지향 모델링 언어
29. 개체지향 프로그래밍 구성요소
    - **객체** : 개체,속성,메소드로 구성된 클래스의 인스턴스
    - **클래스** : 하나 이상의 유사한 객체를 묶어 하나의 공통으로 된 특성
    - **메시지** : 객체 간의 통신
30. 데이터베이스 용어
    - 인덱스 : 겸색 연산을 빠르고 효율적으로 하기 위한 데이터 구조
    - 뷰 : 사용자에게 접근이 허용된 자료만 제한적으로 보여주기 위해 기본테이블에서 유도 되는 테이블
    - 파티션 : 큰 테이블이나 인덱션을 관리하기 쉬운 단위로 물리적으로 분할
31. 전송계층 프로토콜
    - TCP : 연결성 및 신뢰성을 가지며 가상회선 방식을 제공하는 전송프로토콜
    - UDP : 비연결성 및 비신뢰성을 가지며 순서화 되지 않는 데이터그램 서비스를 제공하는 전송프로토콜
32. 웹서비스
    - WSDL : 웹서비스에 대한 상세 정보를 xml형식으로 구현한것 
    - UDDI : WSDL을 등록하고 검색할수있는 저장소, 공개적으로 접근및 검색이 가능하도록 하는 표준
    - SOAP : HTTP,HTTPS,SMTP등을 활용해서 XML기반의 메시지를 네트워크 상에서 교환하는 프로토콜
33. 정규화
    - 릴레이션의 속성들이 서로 상호종속관계를 갖는 특성을 이용해 무손실분해를 하는 과정
    - 반정규화
      - 어플리케이션의 성능을 향상및 개발과 운영의 편의성을위해 정규화 원칙을 위배하는 행위



# *쿼리

1. 학생 테이블에 '이'씨 학생의 학번 출력 쿼리

   ```sql
   select 학번
   from 학생
   where 학생 LIKE '이%';
   ```

   - LIKE문
     - '이'가 들어가있는 사람 : WHERE 학생 LIKE '%이%';
     - '이'가 있고 뒤에 한글지만 있는 사람 : WHERE 학생 LIKE '이_';
     - '이'가 있고 뒤에 두글자만 있는 사람 : WHERE 학생 LIKE '이__';

2. 성적 테이블에서 IN키워드를 이용해서 '컴퓨터 구조'와 '알고리즘'과목에 대한 학번 별 평균 학점을 구하는 쿼리

   ```sql
   select 학번, avg(학점) as 평균
   from 성적
   where 과목 IN ('컴퓨터구조','알고리즘')
   group by 학번;
   ```

   - avg,sum,count와 같은 집계함수는 group by키워드를 사용해야 사용할수 있다.

3. 성적 테이블에서 '컴퓨터 구조'과목을 수강한 사람의 학번과 학점을 학점순(오름차순)으로 정렬하는 쿼리

   ```sql
   select 학번, 학점
   from 성적
   where 과목 = '컴퓨터 구조'
   order by 학점 ASC;
   ```

4. 성적 테이블에서 과목만 출력하는 쿼리(과목 중복x)

   ```sql
   select distinct 과목
   from 성적
   ```

5. 고객테이블에서 나이가 50이상, 59이하, 성별이 남자인 사람의 이름 출력(**BETWEEN사용**)

   ```sql
   select 이름
   from 고객
   where (나이 BETWEEN 50 AND 59) AND (성별='남자');
   ```

6. 학생 테이블에서 가장 높은 성적을 출력

   ```sql
   select 학번, 성적
   from 학생
   where 성적 = (select max(성적) 
              from 학생)
   ```

7. 학생 테이블에서 학생 테이블의 학번 속성을 이용하여 인덱스를 생성하고, 인덱스를 삭제하는 쿼리

   ```sql
   (생성)
   CREATE INDEX INDEX_STUDENT ON 학생(학번);
   
   (삭제)
   DROP INDEX INDEX_STUDENT ON 학생;
   ```

   - 생성 : CREATE INDEX 인덱스명 ON 테이블명(속성명1, 속성명2)
   - 삭제 : DROP INDEX 인덱스명 ON 테이블명; 